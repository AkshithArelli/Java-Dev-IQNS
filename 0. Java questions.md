# 1. OOPs

There are four main pillars of OOPS:

	1.	Encapsulation
	2.	Abstraction
	3.	Inheritance
	4.	Polymorphism

‚∏ª

‚≠ê 1. Encapsulation

Encapsulation means wrapping data and methods into a single unit (a class) and restricting direct access to the data using access modifiers.

It protects data from unintended modifications.

Simple Example
```java
class BankAccount {
    private double balance; // hidden data

    public void deposit(double amount) {
        balance += amount;
    }

    public double getBalance() {
        return balance;
    }
}
```
üëâ balance is private ‚Üí cannot access directly ‚Üí controlled using getter/setter.

üéØ Key point to mention: ‚ÄúEncapsulation ensures data protection.‚Äù

	‚Ä¢	Data lives inside the class
	‚Ä¢	Only methods inside the class can modify it

This is literally the meaning of encapsulation:

‚ÄúWrapping data + methods together as one unit‚Äù

‚∏ª

‚≠ê 2. Abstraction

Abstraction means showing only the essential details and hiding unnecessary internal complexity.

Example
```java
abstract class Payment {
    abstract void pay();
}

class CreditCardPayment extends Payment {
    void pay() {
        System.out.println("Payment done using credit card");
    }
}
```

```java
Payment payment = new CreditCardSystem();
payment.pay();
```
You don‚Äôt need to know how the credit card works internally.

üéØ Key point: ‚ÄúAbstraction reduces complexity and focuses on what an object does, not how it does it.‚Äù

Think of it as:
üëâ ‚ÄúI give you the function, but I hide the internal mechanics.‚Äù

You only see the idea of paying, not the details

‚∏ª

‚≠ê 3. Inheritance

Inheritance allows one class (child/subclass) to acquire properties and methods of another class (parent/superclass).

It promotes code reusability.

Example
```java
class Animal {
    void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}
```
üëâ Dog gets eat() method without writing it again.
üéØ Key point: ‚ÄúInheritance helps with reusability and hierarchical relationships.‚Äù

‚∏ª

‚≠ê 4. Polymorphism

Polymorphism means same method name, different behavior.

There are two types:

	‚Ä¢	Compile-time polymorphism ‚Üí Method Overloading
	‚Ä¢	Runtime polymorphism ‚Üí Method Overriding

‚∏ª

Compile-time Polymorphism (Overloading)
```java
class Calculator {
    int add(int a, int b) { return a+b; }
    int add(int a, int b, int c) { return a+b+c; }
}
```

‚∏ª

Runtime Polymorphism (Overriding)
```java
class Animal {
    void sound() { System.out.println("Animal makes sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Dog barks"); }
}
```
üéØ Key point: ‚ÄúPolymorphism provides flexibility to use one interface with multiple implementations.‚Äù

‚∏ª
Extras:

5. Class vs Object
   
	‚Ä¢	Class ‚Üí Blueprint
	‚Ä¢	Object ‚Üí Instance of class

‚∏ª

6. Interface
   
	‚Ä¢	100% abstraction (before Java 8)
	‚Ä¢	Can have default and static methods
```java
interface Vehicle {
    void start();
}
```

‚∏ª

7. Abstract Class
   
	‚Ä¢	Cannot be instantiated
	‚Ä¢	Can contain abstract + concrete methods
	‚Ä¢	Used for partial abstraction

‚∏ª

8. Constructor
   
	‚Ä¢	Special method used to initialize objects
	‚Ä¢	Same name as class
	‚Ä¢	No return type

‚∏ª

9. Method Overloading vs Overriding
```
Feature	                 Overloading	    Overriding
Runtime/Compile time	 Compile-time	    Runtime
Parameters	             Different	      Same
Class relation	         Same class	      Parent-child
```

‚∏ª

‚ÄúOOPS has four major pillars ‚Äî Encapsulation, Abstraction, Inheritance, and Polymorphism.‚Äù
Then explain each in one line, with example if required.


-------------

# ‚úÖ Abstract Class vs Interface

Abstract Class

	‚Ä¢	Can have abstract + concrete methods
	‚Ä¢	Can have instance variables
	‚Ä¢	Can have constructors
	‚Ä¢	Single inheritance
	‚Ä¢	Used when objects share common behavior + partial implementation

Example
```java
abstract class Animal {
    void eat() { System.out.println("Eating..."); }   // concrete method
    abstract void sound();                           // abstract method
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}
```

‚∏ª

Interface

	‚Ä¢	Only abstract methods (until Java 8)
	‚Ä¢	Can have default & static methods
	‚Ä¢	Only public static final constants
	‚Ä¢	No constructors
	‚Ä¢	Supports multiple inheritance
	‚Ä¢	Used when classes just need to follow a contract

Example
```java
interface Vehicle {
    void start();                 // implicitly abstract
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starting...");
    }
}
```

‚∏ª

üß† One-line memory trick

	‚Ä¢	Interface = ‚ÄúWhat to do‚Äù (no implementation).
	‚Ä¢	Abstract class = ‚ÄúWhat + partial how to do‚Äù (some implementation).

‚∏ª

# 4. Constants vs Enums

‚úÖ Enums vs Constants in Java

üëâ Constants are simple variable values with no enforcement or behavior.

üëâ Enums are powerful, type-safe, self-contained classes that represent a fixed set of related values.
‚∏ª

üîç Practical Example (Why Enums are Better)

‚ùå Using constants:
```java
public static final int PENDING = 0;
public static final int SUCCESS = 1;
public static final int FAILED = 2;

void process(int status) {
    if (status == SUCCESS) {
        ...
    }
}
```
If someone passes 5, code still compiles ‚Üí Not safe.

‚∏ª

‚úÖ Using enums:
```java
enum PaymentStatus {
    PENDING, SUCCESS, FAILED
}

void process(PaymentStatus status) {
    if (status == PaymentStatus.SUCCESS) {
        ...
    }
}
```
If someone passes anything else, the compiler rejects ‚Üí Safe.

‚∏ª

üî• Enums with Behavior

Enums are actually classes, so you can add logic.
```java
enum Direction {
    NORTH(0), SOUTH(180), EAST(90), WEST(270);

    private int angle;

    Direction(int angle) {
        this.angle = angle;
    }

    public int getAngle() {
        return angle;
    }
}
```

‚∏ª

üß† When to Use What?

‚úî Use ENUM when:

	‚Ä¢	Values are fixed (states, directions, types)
	‚Ä¢	You want type safety
	‚Ä¢	You need to attach behavior
	‚Ä¢	You want clean and readable domain models

‚úî Use CONSTANTS when:

	‚Ä¢	It‚Äôs a simple number/string used rarely
	‚Ä¢	Behavior is not required
	‚Ä¢	No need to enforce fixed acceptable values

‚∏ª

Enums are preferred in modern Java for all domain-specific fixed categories.

‚∏ª


# Marker interface

A Marker Interface is an interface that has no methods and no fields.

It is used only to mark a class with some metadata so that JVM or frameworks treat that class differently.

Examples in Java

	‚Ä¢	Serializable
	‚Ä¢	Cloneable
	‚Ä¢	Remote
	‚Ä¢	RandomAccess

‚∏ª

‚ùì Why does Java use Marker Interfaces?

Because before annotations were introduced (Java 1.5), Java needed a way to mark classes with special behavior.

So marker interfaces are used to:
```
‚úî Identify that a class has a special property
‚úî Tell JVM or a library to enable some special logic
‚úî Give metadata at compile time
‚úî Enforce type safety (important!)
```
‚∏ª

üîç Simple Example: Serializable
```java
class Student implements Serializable {
    private int id;
    private String name;
}
```
This tells Java:

‚ÄúThis class can be converted to bytes.‚Äù

If you don‚Äôt implement Serializable and try to serialize it ‚Üí you get NotSerializableException.

‚∏ª

üß† How JVM uses Marker Interfaces?

Marker interfaces are checked using:
```java
if (obj instanceof Serializable) {
    // perform serialization
}
```
So the interface acts as a flag.

‚∏ª

# Java 8 features

üöÄ Introduction

Java 8 (released in 2014) introduced functional programming and stream processing, making Java more concise and expressive.
It was one of the biggest updates to Java since its creation.

‚∏ª

### üß† 1. Lambda Expressions

Definition:

A lambda expression is a short block of code that takes parameters and returns a value ‚Äî used to implement functional interfaces.

Syntax:

(parameters) -> { body }

Example:
```java
// Before Java 8
new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello!");
    }
}).start();

// Java 8
new Thread(() -> System.out.println("Hello!")).start();
```
‚úÖ Benefits

	‚Ä¢	Less boilerplate code
	‚Ä¢	Improves readability
	‚Ä¢	Enables functional-style programming

‚∏ª

### üß† 2. Functional Interfaces

Definition:

A Functional Interface contains only one abstract method.
They can be implemented using lambda expressions.

##### Common Examples in Java
- `Runnable` (single `run()` method)
- `Callable` (single `call()` method)
- `Comparator` (single `compare()` method)
- Java 8 interfaces in `java.util.function` package like `Predicate<T>`, `Function<T, R>`, `Supplier<T>`, etc.

```java
interface Calculator {
    void switchOn();
}

//traditional way
public class Main implements Calculator{

    @Override
    public void switchOn() {
        System.out.println("Turned On");
    }

    public static void main(String args[]) {
        Main obj = new Main();
        obj.switchOn();
    }
}

//using lambda expression
public class Main{
    public static void main(String[] args) {
        //Calculator cal = () -> {System.out.println("Turned On");}
        Calculator cal = () -> System.out.println("Turned On");  //incase of only one statement, we don't need {}
        cal.switchOn();
    }
}
```

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Akshith", "Alex" , "Are");
//traditional way + 2
//        LengthComparator lc = new LengthComparator();
//
//        Collections.sort(names, lc);
//
//        System.out.println(names);

//using lambda, does not require tranditional way + 1 as well
        Collections.sort(names, (a,b) -> Integer.compare(a.length(),b.length()));
        System.out.println(names);
    }
}

//traditional way + 1
class LengthComparator implements Comparator<String> {

    @Override
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(),s2.length());
    }
}
```

##### Consumer, Predicate, and Supplier

Consumer, Predicate, and Supplier are some of the most commonly used.

These interfaces enable functional programming and are widely used with lambda expressions, Streams, and method references.

‚∏ª

#### üì¶ 1. Consumer<T>

‚úÖ Purpose:

Represents an operation that takes a single input and returns no result.

‚úÖ Functional Method:
```java
void accept(T t);
```
üß™ Example:
```java
import java.util.function.Consumer;
//traditional way
public class Main implements Consumer<Integer> {
    @Override
    public void accept(Integer i) {
        System.out.println("printing: " + i);
    }

    public static void main(String[] args) {
        Main obj = new Main();
        obj.accept(1);
    }

}

o/p: printing: 1

//lambda
public class Main {

    public static void main(String[] args) {
        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
        consumer.accept(1);
    }

}

o/p: printing: 1
```
#### Note: forEach() as takes consumer and internally uses accept() method
<img width="745" alt="Screenshot 2025-05-24 at 9 36 00‚ÄØPM" src="https://github.com/user-attachments/assets/31058168-4702-4044-9a46-57a1d8db9c04" />

eg:
```java
public class Main {

    public static void main(String[] args) {
//        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
//        consumer.accept(1);

        List<Integer> list = Arrays.asList(1,2,3,4);
        list.stream().forEach(i -> System.out.println("printing: "+i));
    }

}

o/p:
printing: 1
printing: 2
printing: 3
printing: 4
```

üìù Use Case:

	‚Ä¢	Logging
	‚Ä¢	Printing elements in a list
	‚Ä¢	Performing side effects

‚∏ª

#### ‚úÖ 2. Predicate<T>

‚úÖ Purpose:

Represents a boolean-valued function of one argument. Often used for filtering.

‚úÖ Functional Method:

boolean test(T t);

üß™ Example:
```java
//traditional way
public class Main implements Predicate<Integer> {
    @Override
    public boolean test(Integer integer) {
        return integer % 2 == 0;
    }

    public static void main(String[] args) {
        Main obj = new Main();
        System.out.println(obj.test(4)); //output: true
    }
}

//using lambda
public class Main {

    public static void main(String[] args) {
//        Predicate<Integer> predicate = i -> {
//            return i % 2 == 0;
//        };
        Predicate<Integer> predicate = i -> i%2 == 0;
        System.out.println(predicate.test(5)); //output: false

        //In Java lambda expressions, you can omit the return keyword and curly braces {}
        // when the lambda body contains only a single expression.
        // The expression‚Äôs value is automatically returned.
    }

}
```
#### Note: filter() method of streams accepts predicate as input and internally uses test method
<img width="774" alt="Screenshot 2025-05-24 at 10 10 18‚ÄØPM" src="https://github.com/user-attachments/assets/76e59110-08d1-4f4a-ae5c-9da5bafe2b0e" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Predicate<Integer> predicate = i -> i%2 == 0;
//        System.out.println(predicate.test(5));

        List<Integer> input = Arrays.asList(1,2,3,4);
        input.stream().filter(i -> i%2 == 0)
                .forEach(i -> System.out.println("print even: " + i));

    }

}

output:
print even: 2
print even: 4
```
üìù Use Case:

	‚Ä¢	Filtering collections
	‚Ä¢	Conditional checks

‚∏ª

#### ‚úÖ 3. Supplier<T>

‚úÖ Purpose:

Represents a supplier of results. Takes no input and returns a value.

‚úÖ Functional Method:

T get();

üß™ Example:

```java
//traditional way
public class Main implements Supplier<String> {

    @Override
    public String get() {
        return "hello";
    }

    public static void main(String[] args) {
        //Main obj = new Main();
        Supplier<String> supplier = new Main();
        System.out.println(supplier.get()); //output: hello
    }

}

//lambda
public class Main {

    public static void main(String[] args) {

        Supplier<String> supplier = () -> "hello";
        System.out.println(supplier.get()); //hello
    }
}

```

#### Note: orElseGet of streams internally accepts supplier and users get method
<img width="866" alt="Screenshot 2025-05-24 at 10 27 31‚ÄØPM" src="https://github.com/user-attachments/assets/4a0b745e-f197-4660-9eac-e1c736d43ffd" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Supplier<String> supplier = () -> "hello";
//        System.out.println(supplier.get());

        List<String> list = Arrays.asList();
        System.out.println(list.stream().findAny().orElseGet(() -> "hey nothing found in the list"));

    }
}

output:
hey nothing found in the list
```
üìù Use Case:

	‚Ä¢	Lazy initialization
	‚Ä¢	Generating values or objects
	‚Ä¢	Supplying default values

‚∏ª

### üß† 3. Stream API - Definition, Intermediate & Terminal Functions


#### ‚úÖ Stream API ‚Äî Definition

The Stream API (introduced in Java 8) is a feature used to process data in a declarative, functional style.

A Stream:

	‚Ä¢	Is a sequence of elements (like data from a list, set, or array)
	‚Ä¢	Supports functional operations (map, filter, reduce‚Ä¶)
	‚Ä¢	Does not store data ‚Äî it only processes it
	‚Ä¢	Is lazy ‚Äî intermediate operations run only when a terminal operation is called
	‚Ä¢	Can be parallel (for performance)

üí° Think of stream like a pipeline:

Data enters ‚Üí goes through operations ‚Üí gives output.

‚∏ª

‚úÖ Why Use Streams?

	‚Ä¢	Less code
	‚Ä¢	More readable
	‚Ä¢	Functional operations
	‚Ä¢	Easy transformations
	‚Ä¢	Parallel processing support

‚∏ª

‚úÖ Stream API Pipeline Structure

A Stream pipeline has three parts:

	1.	Source (collection/array/IO data)
	2.	Intermediate operations (map/filter/sorted‚Ä¶)
	3.	Terminal operation (collect/forEach/reduce‚Ä¶)

‚∏ª

#### ‚≠ê 1) STREAM CREATION (Source)

Examples:
```java
Stream<Integer> stream = List.of(1, 2, 3).stream();
Stream<String> stream2 = Stream.of("a", "b", "c");
```

‚∏ª

#### ‚≠ê 2) INTERMEDIATE OPERATIONS

These operations return a Stream and are lazy.

They do not execute until a terminal operation is called.

Common Intermediate Operations:

1Ô∏è‚É£ filter()

Filters data based on a condition.
```java
list.stream()
    .filter(n -> n % 2 == 0)
```
2Ô∏è‚É£ map()

Transforms each element.
```java
list.stream()
    .map(n -> n * 2)
```
3Ô∏è‚É£ flatMap()

Flattens nested structures.
```java
listOfLists.stream()
    .flatMap(List::stream)
```
4Ô∏è‚É£ sorted()

Sorts elements.
```java
list.stream().sorted()
```
5Ô∏è‚É£ distinct()

Removes duplicates.
```java
list.stream().distinct()
```
6Ô∏è‚É£ limit() and skip()

Take or skip first N elements.
```java
list.stream().limit(3)
list.stream().skip(2)
```
7Ô∏è‚É£ peek()

Debugging helper.
```java
list.stream().peek(System.out::println)
```

‚∏ª

#### ‚≠ê 3) TERMINAL OPERATIONS

These operations end the stream pipeline and produce a result

(either a single value, a collection, or a side effect).

Common Terminal Operations:

1Ô∏è‚É£ forEach()

Iterates and performs action.
```java
list.stream().forEach(System.out::println);
```
2Ô∏è‚É£ collect()

Converts stream ‚Üí list/set/map.
```java
List<Integer> result = list.stream()
        .filter(n -> n > 10)
        .collect(Collectors.toList());
```
3Ô∏è‚É£ reduce()

Reduces elements to a single result.
```java
int sum = list.stream()
        .reduce(0, (a, b) -> a + b);
```
4Ô∏è‚É£ count()

Counts elements.
```java
list.stream().count();
```
5Ô∏è‚É£ min() / max()
```java
list.stream().max(Integer::compareTo);
```
6Ô∏è‚É£ anyMatch / allMatch / noneMatch

Checks conditions.
```java
list.stream().anyMatch(n -> n > 10);
```
7Ô∏è‚É£ findFirst / findAny
```java
list.stream().findFirst();
```

‚∏ª

üß† Example of Complete Stream Pipeline

Input: [1, 2, 3, 4, 5]

Task: Multiply even numbers by 10 and collect result.
```java
List<Integer> result = List.of(1,2,3,4,5).stream()
        .filter(n -> n % 2 == 0)    // intermediate
        .map(n -> n * 10)           // intermediate
        .collect(Collectors.toList()); // terminal
```
Output:

[20, 40]

‚∏ª

	‚Ä¢	Stream is not a data structure, it‚Äôs a data-processing pipeline.
	‚Ä¢	Intermediate operations are lazy and return Stream.
	‚Ä¢	Terminal operations trigger execution.
	‚Ä¢	Streams can be parallel for performance.
	‚Ä¢	A stream can be used only once (after terminal op it‚Äôs closed).
	‚Ä¢	Supports functional programming in Java.

‚∏ª

### üß† 4. Default & Static Methods in Interfaces

Before Java 8:

	‚Ä¢	Interfaces could only contain abstract methods.
	‚Ä¢	Adding a new method to an interface broke all implementing classes.

Java 8 introduced:

	‚Ä¢	default methods
	‚Ä¢	static methods

to solve these issues and support functional programming.

‚∏ª

#### ‚úÖ 1. DEFAULT METHODS

A default method is a method inside an interface that has a body (implementation).

‚úî Why default methods?

To add new methods to an interface without breaking existing implementations.

Example:
```java
interface Vehicle {
    void start();

    default void honk() {
        System.out.println("Honking...");
    }
}
```
‚úî Key Points:

	‚Ä¢	A class inheriting the interface gets this method automatically.
	‚Ä¢	Implementing class may override it ‚Äî but not required.
	‚Ä¢	Helps maintain backward compatibility.

‚úî Example Usage:
```java
class Car implements Vehicle {
    public void start() {
        System.out.println("Car started");
    }
}

public class Test {
    public static void main(String[] args) {
        Vehicle v = new Car();
        v.honk(); // default method
    }
}
```
‚∏ª

‚ö° When to Use Default Methods?

	‚Ä¢	When you want to provide optional behavior.
	‚Ä¢	When adding a method to an interface used by many classes (to avoid breaking them).
	‚Ä¢	When providing reusable utility logic, but still allowing override.

‚∏ª

#### ‚úÖ 2. STATIC METHODS IN INTERFACES

Static methods in interfaces are similar to static methods in classes ‚Äî but they belong to the interface itself.

‚úî Why static methods?

To provide utility/helper methods related to the interface.

Example:
```java
interface MathUtils {
    static int add(int a, int b) {
        return a + b;
    }
}
```
‚úî How to call them?

int result = MathUtils.add(5, 10); 

‚úî Key Points:

	‚Ä¢	Cannot be overridden by implementing classes.
	‚Ä¢	Cannot be called using an object reference.
```java
MathUtils obj = new MathUtils(); // ‚ùå not allowed
obj.add(1,2);                   // ‚ùå not allowed
```

	‚Ä¢	Must be called using interface name.

‚∏ª

üß† Simple Intuition

	‚Ä¢	default ‚Üí ‚ÄúI will provide a default behavior; classes can use or override it.‚Äù
	‚Ä¢	static ‚Üí ‚ÄúThis is a helper function; it belongs to the interface class itself.‚Äù


‚∏ª

#### ‚úÖ What if your class implements two interfaces having the same default method?

This creates a diamond problem:
Both interfaces offer the same method signature + default implementation.

Example:
```java
interface A {
    default void hello() { System.out.println("Hello from A"); }
}

interface B {
    default void hello() { System.out.println("Hello from B"); }
}

class C implements A, B {
}
```

üëâ This does NOT compile.

Java doesn‚Äôt know which default method to inherit.

‚ùóCompiler Error:

class C inherits unrelated defaults for hello() from A and B


‚∏ª

#### How to solve it?

You must override the method in your class and choose which interface‚Äôs method you want.
```java
class C implements A, B {
    @Override
    public void hello() {
        A.super.hello(); // Calling Interface A's default method
        // OR
        // B.super.hello();
    }
}
```

‚∏ª

#### How to call the method in Interface A inside implementing class?

Use:
```java
A.super.methodName();
```
Example:
```java
class C implements A, B {
    @Override
    public void hello() {
        A.super.hello();   // Calls A's default method
    }
}
```

‚∏ª

#### Why can‚Äôt you call a default method directly in main?

Because:

‚úî Default methods belong to objects, not to the interface type.

You must always call them through an instance, not via interface name.

Example (not allowed):
```java
A.hello();  // ‚ùå Compile error
```
Error:

Non-static method hello() cannot be referenced from a static context

‚úî Why?

Because default methods are essentially instance methods, added to the class that implements the interface.

‚úî Correct way:
```java
A obj = new C();
obj.hello();  // ‚úî works
```

‚∏ª

Purpose	Add new behavior without breaking old code	Utility/helper methods

‚úî Two interfaces with same default method?

Implementing class must override and choose explicitly.

‚úî Call interface-specific default method?

InterfaceName.super.methodName();

‚úî Why you can‚Äôt call default method from main using interface name?

Because default methods are instance methods, not static methods.

‚∏ª


### üß† 5. Optional Class

Purpose:

To handle null values safely without NullPointerException.

Example:
```
		Optional<String> name = Optional.ofNullable(null);
		System.out.println(name.orElse("Default Name")); //Default Name
		name.ifPresent(System.out::println); // does not execute
		System.out.println(name.orElse("nothing"));  //nothing

        Optional<String> name = Optional.ofNullable("Kate");
        System.out.println(name.isPresent()); // true 

        System.out.println(name.orElse("nothing"));  //Kate

        name.ifPresent(System.out::println); //Kate
```
Common Methods:

	‚Ä¢	isPresent() ‚Üí check value presence
	‚Ä¢	orElse() ‚Üí provide default
	‚Ä¢	ifPresent() ‚Üí run code if not null

‚úÖ Benefits

	‚Ä¢	Null-safe code
	‚Ä¢	Improves readability

‚∏ª

### üß† 6. New Date and Time API (java.time)

Replaces Date and Calendar with immutable, thread-safe, and easy-to-use classes.

Example:
```
import java.time.*;

LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(2000, Month.JUNE, 15);

Period age = Period.between(birthday, today);
System.out.println("Age: " + age.getYears());
```
Main Classes:

	‚Ä¢	LocalDate, LocalTime, LocalDateTime
	‚Ä¢	Period, Duration
	‚Ä¢	ZonedDateTime

‚úÖ Benefits

	‚Ä¢	Easier to format and manipulate
	‚Ä¢	Immutable and thread-safe

‚∏ª

### üß† 7. Method References

Definition:

Shortcut for lambda expressions that call existing methods.

Example:
```java
List<String> names = Arrays.asList("Akshith", "Yashwanth", "Arelli");

// Lambda
names.forEach(n -> System.out.println(n));

// Method reference
names.forEach(System.out::println);
```
Types of References:

	‚Ä¢	Class::staticMethod
	‚Ä¢	object::instanceMethod
	‚Ä¢	Class::new (constructor reference)

‚∏ª

### üß† 8. Parallel Streams

Definition:

Runs stream operations in multiple threads to increase performance on large data sets.

Example:
```java
List<Integer> numbers = IntStream.rangeClosed(1, 1000000)
                                 .boxed()
                                 .collect(Collectors.toList());

long sum = numbers.parallelStream()
                  .mapToLong(i -> i)
                  .sum();

System.out.println(sum);
```
‚ö†Ô∏è Use carefully:

Parallel processing overhead can reduce performance for small datasets.

‚∏ª

üßæ Summary Table

Feature					Purpose											Example
Lambda					Write concise code								(x) -> x * 2
Functional Interface	Enable lambdas									@FunctionalInterface
Stream API				Process collections easily						stream().filter()
Default/Static Methods	Extend interfaces								default void print()
Optional				Handle nulls safely								Optional.ofNullable()
Date & Time API			Modern date handling							LocalDate.now()
Method Reference		Simplify lambdas								System.out::println
Parallel Streams		Multi-threaded data ops							parallelStream()
Nashorn	Run JavaScript	engine.eval("JS")

‚∏ª

# 2. Exception Hierarchy
```
java.lang.Object
     ‚Üì
  Throwable
   ‚îú‚îÄ‚îÄ Error (unchecked)
   ‚îÇ      ‚îú‚îÄ‚îÄ OutOfMemoryError
   ‚îÇ      ‚îú‚îÄ‚îÄ StackOverflowError
   ‚îÇ      ‚îî‚îÄ‚îÄ etc...
   ‚îî‚îÄ‚îÄ Exception
          ‚îú‚îÄ‚îÄ RuntimeException (unchecked)
          ‚îÇ       ‚îú‚îÄ‚îÄ NullPointerException
          ‚îÇ       ‚îú‚îÄ‚îÄ ArithmeticException
          ‚îÇ       ‚îú‚îÄ‚îÄ IllegalArgumentException
          ‚îÇ       ‚îî‚îÄ‚îÄ ArrayIndexOutOfBoundsException
          ‚îî‚îÄ‚îÄ Checked Exceptions
                  ‚îú‚îÄ‚îÄ IOException
                  ‚îú‚îÄ‚îÄ SQLException
                  ‚îú‚îÄ‚îÄ ParseException
                  ‚îî‚îÄ‚îÄ ClassNotFoundException
```

- Exception hierarchy starts from Throwable class.

- Throwable has two children: Error and Exception.

- Errors are unrecoverable and represent issues outside application control.

- Exceptions are recoverable and divided into 

1. Checked exceptions (must be handled) 

These are exceptions that the compiler forces you to handle.

You MUST either:

	‚Ä¢	use try-catch
	‚Ä¢	or throws in method signature

Examples:

	‚Ä¢	IOException
	‚Ä¢	SQLException
	‚Ä¢	FileNotFoundException
	‚Ä¢	ClassNotFoundException


2. Unchecked exceptions (RuntimeException).

These happen during execution due to programming errors. Compiler does NOT force you to catch them.

Examples:

	‚Ä¢	NullPointerException
	‚Ä¢	ArithmeticException
	‚Ä¢	ArrayIndexOutOfBoundsException
	‚Ä¢	IllegalArgumentException
	‚Ä¢	ClassCastException


‚∏ª

‚≠ê 1. try

The try block contains code that might throw an exception.
```java
try {
    riskyCode();
}
```
Purpose:

‚úî Detect errors at runtime
‚úî Prevent application crash
‚úî Transfer control to a catch/finally block

‚∏ª

‚≠ê 2. catch

The catch block handles the exception thrown inside the try block.
```java
catch(Exception e) {
    System.out.println(e.getMessage());
}
```
Purpose:

‚úî Handle the error
‚úî Recover or show meaningful message
‚úî Log the issue

You can have:

	‚Ä¢	Multiple catch blocks
	‚Ä¢	Catching specific exceptions first (most specific ‚Üí most general)

‚∏ª

‚≠ê 3. finally

The finally block executes always, whether exception occurs or not.
```java
finally {
    closeResources();
}
```
Runs in:
‚úî Normal execution
‚úî Exception thrown
‚úî Exception handled
‚úî Exception not handled
‚úî Even after return statement inside try/catch

Purpose:
‚úî Clean-up code
‚úî Closing files/DB connections
‚úî Releasing resources

‚∏ª

‚≠ê 4. throw

throw is used to explicitly throw an exception inside code.

throw new IllegalArgumentException("Invalid input");

Uses:

	‚Ä¢	For custom validations
	‚Ä¢	Manual exceptions
	‚Ä¢	Business rule violations

Example:
```java
if(age < 18) {
    throw new RuntimeException("Not allowed");
}
```

‚∏ª

‚≠ê 5. throws

throws is used in method declaration to say:

‚ÄúThis method may throw an exception ‚Äî caller must handle it.‚Äù
```java
void readFile() throws IOException {
    // risky code
}
```
It does not throw exception.

It just declares the possibility.

Used mainly for:

‚úî Checked exceptions
‚úî Declaring contract for caller

‚∏ª

## Custom Exceptions

A custom exception is a user-defined exception that helps represent business-specific errors more clearly.
We create custom checked exceptions by extending Exception and custom unchecked exceptions by extending RuntimeException.‚Äù


A custom exception is an exception you define yourself when Java‚Äôs built-in exceptions are not enough for your business logic.

For example:

	‚Ä¢	‚ÄúInsufficientBalanceException‚Äù
	‚Ä¢	‚ÄúInvalidAgeException‚Äù
	‚Ä¢	‚ÄúUnauthorizedUserException‚Äù
	‚Ä¢	‚ÄúOrderNotFoundException‚Äù

They make your code more meaningful, readable, and domain-specific.

‚∏ª

üü¶ Types of Custom Exceptions

You can create:

1Ô∏è‚É£ Custom Checked Exceptions

Extend Exception.

2Ô∏è‚É£ Custom Unchecked Exceptions

Extend RuntimeException.

‚∏ª

üü¶ 1. Custom Checked Exception

üëâ Use when caller must handle the exception

(either try-catch or throws)

Example: InvalidAgeException
```java
class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}

//Use it:

public void register(int age) throws InvalidAgeException {
    if (age < 18) {
        throw new InvalidAgeException("Age must be 18 or above");
    }
}
```

‚∏ª

üü© 2. Custom Unchecked Exception

üëâ Use when the exception is caused by programming errors

(no need to force try-catch)

Extend RuntimeException.
```java
class InsufficientBalanceException extends RuntimeException {
    public InsufficientBalanceException(String message) {
        super(message);
    }
}

//Use it:

public void withdraw(double amount) {
    if (amount > balance) {
        throw new InsufficientBalanceException("Not enough balance");
    }
}
```

‚∏ª

üüß Checked vs Unchecked Custom Exceptions
```
Type Extend			Must be caught?		When to use
Checked	Exception	Yes (compile-time)	Expected business rule failures
Unchecked			RuntimeException	No	Code bugs, invalid input, illegal states
```

‚∏ª

## Why do we need to use super(message); in custom exceptions?


Because Exception, RuntimeException, and Throwable (the parent classes) already have a constructor that accepts an error message.

Example from Java source:
```java
public Throwable(String message) {
    this.detailMessage = message;
}
```
So when you write:

super(message);

You are sending your custom message up to the parent class, so that:

‚úî The exception stores the message

‚úî The message appears in the logs

‚úî getMessage() returns your message

‚úî Stack trace shows helpful information

‚∏ª

üü¶ Without super(message) ‚Äî the exception message becomes NULL

Example:
```
class MyException extends RuntimeException {
    public MyException() {
        // NO super(message)
    }
}
```
Using it:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: null
```
‚ùå No message
‚ùå Hard to debug
‚ùå Useless in logs and monitoring

‚∏ª

üü© With super(message) ‚Äî message is preserved
```java
class MyException extends RuntimeException {
    public MyException(String message) {
        super(message);
    }
}
```
Now:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: Something went wrong
```
‚úî Message is visible
‚úî Debugging becomes easy
‚úî Logs become meaningful

‚∏ª

We use super(message) to pass our custom error message to the parent Exception class. This allows the exception to store the message, display it in the stack trace, and retrieve it through getMessage(). Without it, the message will be lost.

‚∏ª

üî• Bonus: super(cause) and super(message, cause)

Exception classes allow:
```java
super(cause);           // chain exception
super(message, cause);  // message + root cause
```
These help track real underlying failures.

---------------

# 3. try-with-resources

try-with-resources is a Java feature that automatically closes resources (like files, DB connections, sockets, streams) after their usage ‚Äî without requiring a finally block.

A resource is anything that implements the interface:

AutoCloseable


‚∏ª

üö´ Old way (before Java 7): Manual closing

Using a file:
```java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader("data.txt"));
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
} finally {
    try {
        if (br != null) br.close();   // must close manually
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
Problems:

‚ùå Long code
‚ùå Easy to forget closing
‚ùå Possible memory/resource leaks

‚∏ª

‚úÖ New way (after Java 7): try-with-resources
```java
try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
}
```
Advantages:

‚úî Resource automatically closed
‚úî No need for finally block
‚úî Cleaner code
‚úî Prevents resource leaks
‚úî More readable

‚∏ª

üß† How it works internally?

At the end of the try block, Java automatically calls:
```java
br.close();
``
* because BufferedReader implements:
```
public interface Closeable extends AutoCloseable
```
* So anything implementing AutoCloseable works with try-with-resources.

‚∏ª

‚ÄúTry-with-resources is a Java feature that automatically closes resources at the end of a try block. Any class implementing AutoCloseable can be used. This avoids memory leaks and makes code cleaner compared to the old try-catch-finally approach.‚Äù

‚∏ª

‚≠ê Extra imp Points

1. Resources are closed in reverse order

Last opened ‚Üí closed first.

2. Works with custom resources

You can create your own class:
```java
class MyResource implements AutoCloseable {
    @Override
    public void close() {
        System.out.println("Closed automatically");
    }
}
```
Then:
```java
try (MyResource r = new MyResource()) {
    // use resource
}
```
3. Finally block is not required

4. Less error-prone ‚Üí prevents resource leaks

‚∏ª

### Controller Advice, Rest Controller Advice, Exception Handler


üåü 1. @ControllerAdvice

‚úî What is it?

@ControllerAdvice is a global exception-handling mechanism in Spring MVC.

Think of it as a central place where:

	‚Ä¢	You handle exceptions for all controllers
	‚Ä¢	You write common error-handling logic
	‚Ä¢	You avoid repeating try/catch in every controller

‚úî Key Point:

It works for:

	‚Ä¢	@Controller
	‚Ä¢	@RestController

‚úî Example:
```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NullPointerException.class)
    public String handleNullPointer(NullPointerException ex) {
        return "error-page";   // returns view name
    }
}
```
üí° @ControllerAdvice is usually used in MVC apps that return views (HTML/JSP).

‚∏ª

üåü 2. @RestControllerAdvice

‚úî What is it?

@RestControllerAdvice = @ControllerAdvice + @ResponseBody

Meaning:

	‚Ä¢	Returns JSON responses
	‚Ä¢	Used in REST APIs

‚úî Example:
```java
@RestControllerAdvice
public class RestGlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ErrorResponse handleIllegalArgument(IllegalArgumentException ex) {

        return new ErrorResponse("INVALID_INPUT", ex.getMessage());
    }
}
```
üí° Use this in REST microservices built with Spring Boot.

‚∏ª

üåü 3. @ExceptionHandler

‚úî What is it?

@ExceptionHandler is used inside a Controller or inside ControllerAdvice to handle specific exceptions.

It tells Spring:

‚ÄúWhenever this exception occurs, call this method.‚Äù

‚úî Example inside @RestControllerAdvice:
```java
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<?> handleResourceNotFound(ResourceNotFoundException ex) {
    return ResponseEntity.status(404).body(ex.getMessage());
}
```
‚úî It can handle:

	‚Ä¢	One exception
	‚Ä¢	Multiple exceptions
```java
@ExceptionHandler({NullPointerException.class, IllegalStateException.class})
```

‚∏ª

‚≠ê How They Work Together (Big Picture)
```
Controller throws exception

‚¨á
Spring searches for local @ExceptionHandler
‚¨á
If not found ‚Üí checks @ControllerAdvice / @RestControllerAdvice
‚¨á
Returns response
```
‚∏ª

‚≠ê Quick Summary Table
```
Annotation					Type			Used For						Returns	Best 		Use Case
@ControllerAdvice			Global			MVC Controllers					View (HTML)			Web apps
@RestControllerAdvice		Global			REST Controllers				JSON				REST APIs / Microservices
@ExceptionHandler			Local or Global	Handling specific exceptions	View or JSON		Business exceptions
```

‚∏ª

üåü Full Working Example (REST API)

üéØ Controller
```java
@RestController
public class UserController {

    @GetMapping("/user/{id}")
    public String getUser(@PathVariable int id) {
        if(id <= 0) {
            throw new IllegalArgumentException("Invalid user id");
        }
        return "User found";
    }
}
```

‚∏ª

üéØ Global Exception Handler
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegal(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleOther(Exception ex) {
        return ResponseEntity.status(500).body("Something went wrong");
    }
}
```

‚∏ª

üåü Output
```
Call: /user/-1
Response:

Invalid user id
```

‚∏ª
```
To avoid writing repetitive try/catch inside controllers.

It gives a common, centralized place to handle exceptions and improve code cleanliness.
```

‚∏ª


# Sealed Classes in Java

Sealed classes (introduced in Java 17) allow you to control which classes are allowed to extend or implement a class or interface.

Think of it like saying:

‚ÄúOnly these specific subclasses are allowed. No one else can extend me.‚Äù

This gives:

	‚Ä¢	Better control over inheritance
	‚Ä¢	More secure and predictable class hierarchies
	‚Ä¢	Helps the compiler perform better exhaustiveness checks (like switch-expressions)

‚∏ª

‚úÖ Why do we need Sealed Classes?

Because normal inheritance is too open:

class A {}

Anyone can extend class A.

With sealed classes, you restrict this:

sealed class A permits B, C {}

Now only B and C can extend A.


‚∏ª

‚úÖ Syntax of Sealed Classes

1. Declaring a sealed class
```java
public sealed class Vehicle permits Car, Bike {}
```
2. Subclasses must choose exactly one of:
   
	‚Ä¢	final ‚Üí cannot be extended further
	‚Ä¢	sealed ‚Üí can further restrict its children
	‚Ä¢	non-sealed ‚Üí open for extension

Example:
```java
public final class Car extends Vehicle {}        // no further extension allowed
public non-sealed class Bike extends Vehicle {}  // others can extend Bike
```
‚∏ª

‚ùå Common Misconceptions

‚ùå ‚ÄúSealed class means it cannot be extended.‚Äù

No.

It can be extended ‚Äî but only by permitted subclasses.

‚ùå ‚ÄúSealed is same as final.‚Äù

No.

final = no one can extend

sealed = some can extend

non-sealed = anyone can extend


A sealed class restricts which classes can extend or implement it. Its child classes must explicitly choose to be final, sealed, or non-sealed. It ensures controlled inheritance and helps the compiler with pattern matching.

‚∏ª

# 5. Fail-Fast vs Fail-Safe

1. Fail-Fast Iterator

A fail-fast iterator immediately throws an exception if the underlying collection is structurally modified while iterating.

üî• Example collections (fail-fast)

	‚Ä¢	ArrayList
	‚Ä¢	HashMap
	‚Ä¢	LinkedList
	‚Ä¢	HashSet
	‚Ä¢	Vector (iterator)
	‚Ä¢	Most collections from java.util package

üî• Behavior

If the collection is modified (add/remove) during iteration:

üëâ ConcurrentModificationException is thrown.

‚úî Why?

Fail-fast iterators use a variable called modCount.

Every structural modification changes the modCount.

Iterator compares expectedModCount with modCount. If mismatch ‚Üí throw exception.

‚∏ª

‚ùå Fail-Fast Example
```java
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {          // iterator internally
    list.add("D");               // modification during iteration
}
```
üëâ This throws ConcurrentModificationException.

‚∏ª

2. Fail-Safe Iterator

Fail-safe iterators do NOT throw exceptions if the collection is modified during iteration.

üî• Example collections (fail-safe)

Collections from java.util.concurrent package:

	‚Ä¢	CopyOnWriteArrayList
	‚Ä¢	ConcurrentHashMap
	‚Ä¢	ConcurrentSkipListMap
	‚Ä¢	ConcurrentSkipListSet

üî• Behavior

Fail-safe iterators work on a clone (copy) of the collection.

üëâ Modifying the original collection does not affect the iterator.
üëâ No ConcurrentModificationException.

‚∏ª

‚úî Fail-Safe Example
```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {
    list.add("D");   // allowed
}
```
üëâ No exception.
üëâ Iterator reads old snapshot; new values appear after iteration ends.

‚∏ª

üî• Key Differences
```
Feature								Fail-Fast										Fail-Safe
Behavior on modification			Throws ConcurrentModificationException			No exception
Works on							Actual collection								Copy (snapshot)
Memory usage						Low												High (copy created)
Speed								Faster											Slower
Example collections					ArrayList, HashMap, HashSet						CopyOnWriteArrayList, ConcurrentHashMap
Thread-safety						Not thread-safe									Thread-safe
Iterator type						Fail-fast iterator								Snapshot iterator
```

‚∏ª

üß† Why do they exist?

Fail-Fast

	‚Ä¢	Detect inconsistent modifications quickly.
	‚Ä¢	Prevents unpredictable behavior.

Fail-Safe

	‚Ä¢	Useful for concurrent environments.
	‚Ä¢	Allows iteration while modifications happen.

‚∏ª

üéØ Summary

Fail-fast iterators throw ConcurrentModificationException if the collection is structurally modified during iteration because they work on the actual collection. Fail-safe iterators do not throw exceptions because they work on a cloned snapshot of the collection. Fail-safe is used in concurrent collections, while fail-fast is used in regular collections.


‚∏ª

### Reentrant Lock

A ReentrantLock is a lock with the ability to be acquired multiple times by the same thread without causing a deadlock.

If a thread owns the lock, it can enter the same lock-protected code block again without blocking itself.

Each acquisition must be released the same number of times.

It is part of java.util.concurrent.locks.

‚∏ª

üîπ Why use ReentrantLock instead of synchronized?
```
Feature					synchronized	ReentrantLock
Lock acquisition		Implicit		Explicit (lock() / unlock())
Fairness				No control		Can be fair (FIFO)
Try lock					‚ùå			‚úÖ tryLock() avoids blocking
Interruptible				‚ùå			‚úÖ lockInterruptibly()
```

‚∏ª

üîπ Key Properties

	‚Ä¢	Reentrant: Same thread can acquire the lock multiple times
	‚Ä¢	Explicit unlock: Must call unlock() in finally block
	‚Ä¢	Fairness: Optional FIFO ordering

‚∏ª

üîπ Example
```java
import java.util.concurrent.locks.ReentrantLock;

public class Counter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        lock.lock(); // acquire lock
        try {
            count++;
            // even if we call increment again in the same thread, it won't deadlock
        } finally {
            lock.unlock(); // release lock
        }
    }

    public int getCount() {
        return count;
    }
}

Using tryLock() (non-blocking)

if(lock.tryLock()) {
    try {
        // do work
    } finally {
        lock.unlock();
    }
} else {
    // lock not acquired, do something else
}
```

‚∏ª

üîπ Key Points to Remember

	1.	Reentrant = same thread can acquire multiple times
	2.	Manual control vs synchronized
	3.	Supports advanced features: tryLock(), lockInterruptibly(), fairness
	4.	Always unlock in finally block to avoid deadlocks

‚∏ª

### Future vs Completable Future

üîπ 1. Future

	‚Ä¢	Introduced in Java 5 (java.util.concurrent.Future).
	‚Ä¢	Represents the result of an asynchronous computation.
	‚Ä¢	Can get the result using get(), which blocks the thread until the computation is done.
	‚Ä¢	Cannot easily chain multiple tasks or handle callbacks without extra boilerplate.
	‚Ä¢	Cannot be completed manually.

Example
```java
ExecutorService executor = Executors.newFixedThreadPool(1);

Future<Integer> future = executor.submit(() -> {
    Thread.sleep(1000);
    return 10;
});

System.out.println(future.get()); // blocks until result is ready
executor.shutdown();
```
Limitations of Future:

	‚Ä¢	Blocking get()
	‚Ä¢	No easy way to chain tasks (thenApply)
	‚Ä¢	Cannot complete manually (only by executor)

‚∏ª

üîπ 2. CompletableFuture

	‚Ä¢	Introduced in Java 8 (java.util.concurrent.CompletableFuture).
	‚Ä¢	Extends Future with non-blocking, async capabilities.
	‚Ä¢	Supports:
	‚Ä¢	Chaining (thenApply, thenAccept)
	‚Ä¢	Combining multiple futures (thenCombine, allOf, anyOf)
	‚Ä¢	Exception handling (exceptionally, handle)
	‚Ä¢	Can be completed manually using complete().

Example
```java
public static void main(String[] args) {
    CompletableFuture<Integer> cf = CompletableFuture.supplyAsync(() -> {
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
        return 20;
    });

    cf.thenApply(result -> result * 2)
      .thenAccept(result -> System.out.println("Result: " + result));

    System.out.println("Main thread continues working...");

    // No .get(), so main thread is not blocked
}
```
Output:
```
Main thread continues working...
Result: 40   <-- printed after 1 sec by another thread
```
‚∏ª
