# 1. OOPs

There are four main pillars of OOPS:

	1.	Encapsulation
	2.	Abstraction
	3.	Inheritance
	4.	Polymorphism

‚∏ª

‚≠ê 1. Encapsulation

Encapsulation means wrapping data and methods into a single unit (a class) and restricting direct access to the data using access modifiers.

It protects data from unintended modifications.

Simple Example
```java
class BankAccount {
    private double balance; // hidden data

    public void deposit(double amount) {
        balance += amount;
    }

    public double getBalance() {
        return balance;
    }
}
```
üëâ balance is private ‚Üí cannot access directly ‚Üí controlled using getter/setter.

üéØ Key point to mention: ‚ÄúEncapsulation ensures data protection.‚Äù

	‚Ä¢	Data lives inside the class
	‚Ä¢	Only methods inside the class can modify it

This is literally the meaning of encapsulation:

‚ÄúWrapping data + methods together as one unit‚Äù

‚∏ª

‚≠ê 2. Abstraction

Abstraction means showing only the essential details and hiding unnecessary internal complexity.

Example
```java
abstract class Payment {
    abstract void pay();
}

class CreditCardPayment extends Payment {
    void pay() {
        System.out.println("Payment done using credit card");
    }
}
```

```java
Payment payment = new CreditCardSystem();
payment.pay();
```
You don‚Äôt need to know how the credit card works internally.

üéØ Key point: ‚ÄúAbstraction reduces complexity and focuses on what an object does, not how it does it.‚Äù

Think of it as:
üëâ ‚ÄúI give you the function, but I hide the internal mechanics.‚Äù

You only see the idea of paying, not the details

‚∏ª

‚≠ê 3. Inheritance

Inheritance allows one class (child/subclass) to acquire properties and methods of another class (parent/superclass).

It promotes code reusability.

Example
```java
class Animal {
    void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}
```
üëâ Dog gets eat() method without writing it again.
üéØ Key point: ‚ÄúInheritance helps with reusability and hierarchical relationships.‚Äù

‚∏ª

‚≠ê 4. Polymorphism

Polymorphism means same method name, different behavior.

There are two types:

	‚Ä¢	Compile-time polymorphism ‚Üí Method Overloading
	‚Ä¢	Runtime polymorphism ‚Üí Method Overriding

‚∏ª

Compile-time Polymorphism (Overloading)
```java
class Calculator {
    int add(int a, int b) { return a+b; }
    int add(int a, int b, int c) { return a+b+c; }
}
```

‚∏ª

Runtime Polymorphism (Overriding)
```java
class Animal {
    void sound() { System.out.println("Animal makes sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Dog barks"); }
}
```
üéØ Key point: ‚ÄúPolymorphism provides flexibility to use one interface with multiple implementations.‚Äù

‚∏ª
Extras:

5. Class vs Object
   
	‚Ä¢	Class ‚Üí Blueprint
	‚Ä¢	Object ‚Üí Instance of class

‚∏ª

6. Interface
   
	‚Ä¢	100% abstraction (before Java 8)
	‚Ä¢	Can have default and static methods
```java
interface Vehicle {
    void start();
}
```

‚∏ª

7. Abstract Class
   
	‚Ä¢	Cannot be instantiated
	‚Ä¢	Can contain abstract + concrete methods
	‚Ä¢	Used for partial abstraction

‚∏ª

8. Constructor
   
	‚Ä¢	Special method used to initialize objects
	‚Ä¢	Same name as class
	‚Ä¢	No return type

‚∏ª

9. Method Overloading vs Overriding
```
Feature	                 Overloading	    Overriding
Runtime/Compile time	 Compile-time	    Runtime
Parameters	             Different	      Same
Class relation	         Same class	      Parent-child
```

‚∏ª

‚ÄúOOPS has four major pillars ‚Äî Encapsulation, Abstraction, Inheritance, and Polymorphism.‚Äù
Then explain each in one line, with example if required.


-------------

# ‚úÖ Abstract Class vs Interface

Abstract Class

	‚Ä¢	Can have abstract + concrete methods
	‚Ä¢	Can have instance variables
	‚Ä¢	Can have constructors
	‚Ä¢	Single inheritance
	‚Ä¢	Used when objects share common behavior + partial implementation

Example
```java
abstract class Animal {
    void eat() { System.out.println("Eating..."); }   // concrete method
    abstract void sound();                           // abstract method
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}
```

‚∏ª

Interface

	‚Ä¢	Only abstract methods (until Java 8)
	‚Ä¢	Can have default & static methods
	‚Ä¢	Only public static final constants
	‚Ä¢	No constructors
	‚Ä¢	Supports multiple inheritance
	‚Ä¢	Used when classes just need to follow a contract

Example
```java
interface Vehicle {
    void start();                 // implicitly abstract
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car starting...");
    }
}
```

‚∏ª

üß† One-line memory trick

	‚Ä¢	Interface = ‚ÄúWhat to do‚Äù (no implementation).
	‚Ä¢	Abstract class = ‚ÄúWhat + partial how to do‚Äù (some implementation).

‚∏ª

# 4. Constants vs Enums

‚úÖ Enums vs Constants in Java

üëâ Constants are simple variable values with no enforcement or behavior.

üëâ Enums are powerful, type-safe, self-contained classes that represent a fixed set of related values.
‚∏ª

üîç Practical Example (Why Enums are Better)

‚ùå Using constants:
```java
public static final int PENDING = 0;
public static final int SUCCESS = 1;
public static final int FAILED = 2;

void process(int status) {
    if (status == SUCCESS) {
        ...
    }
}
```
If someone passes 5, code still compiles ‚Üí Not safe.

‚∏ª

‚úÖ Using enums:
```java
enum PaymentStatus {
    PENDING, SUCCESS, FAILED
}

void process(PaymentStatus status) {
    if (status == PaymentStatus.SUCCESS) {
        ...
    }
}
```
If someone passes anything else, the compiler rejects ‚Üí Safe.

‚∏ª

üî• Enums with Behavior

Enums are actually classes, so you can add logic.
```java
enum Direction {
    NORTH(0), SOUTH(180), EAST(90), WEST(270);

    private int angle;

    Direction(int angle) {
        this.angle = angle;
    }

    public int getAngle() {
        return angle;
    }
}
```

‚∏ª

üß† When to Use What?

‚úî Use ENUM when:

	‚Ä¢	Values are fixed (states, directions, types)
	‚Ä¢	You want type safety
	‚Ä¢	You need to attach behavior
	‚Ä¢	You want clean and readable domain models

‚úî Use CONSTANTS when:

	‚Ä¢	It‚Äôs a simple number/string used rarely
	‚Ä¢	Behavior is not required
	‚Ä¢	No need to enforce fixed acceptable values

‚∏ª

Enums are preferred in modern Java for all domain-specific fixed categories.

‚∏ª


# Marker interface

A Marker Interface is an interface that has no methods and no fields.

It is used only to mark a class with some metadata so that JVM or frameworks treat that class differently.

Examples in Java

	‚Ä¢	Serializable
	‚Ä¢	Cloneable
	‚Ä¢	Remote
	‚Ä¢	RandomAccess

‚∏ª

‚ùì Why does Java use Marker Interfaces?

Because before annotations were introduced (Java 1.5), Java needed a way to mark classes with special behavior.

So marker interfaces are used to:
```
‚úî Identify that a class has a special property
‚úî Tell JVM or a library to enable some special logic
‚úî Give metadata at compile time
‚úî Enforce type safety (important!)
```
‚∏ª

üîç Simple Example: Serializable
```java
class Student implements Serializable {
    private int id;
    private String name;
}
```
This tells Java:

‚ÄúThis class can be converted to bytes.‚Äù

If you don‚Äôt implement Serializable and try to serialize it ‚Üí you get NotSerializableException.

‚∏ª

üß† How JVM uses Marker Interfaces?

Marker interfaces are checked using:
```java
if (obj instanceof Serializable) {
    // perform serialization
}
```
So the interface acts as a flag.

‚∏ª

# Java 8 features

üöÄ Introduction

Java 8 (released in 2014) introduced functional programming and stream processing, making Java more concise and expressive.
It was one of the biggest updates to Java since its creation.

‚∏ª

### üß† 1. Lambda Expressions

Definition:

A lambda expression is a short block of code that takes parameters and returns a value ‚Äî used to implement functional interfaces.

Syntax:

(parameters) -> { body }

Example:
```java
// Before Java 8
new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello!");
    }
}).start();

// Java 8
new Thread(() -> System.out.println("Hello!")).start();
```
‚úÖ Benefits

	‚Ä¢	Less boilerplate code
	‚Ä¢	Improves readability
	‚Ä¢	Enables functional-style programming

‚∏ª

### üß† 2. Functional Interfaces

Definition:

A Functional Interface contains only one abstract method.
They can be implemented using lambda expressions.

##### Common Examples in Java
- `Runnable` (single `run()` method)
- `Callable` (single `call()` method)
- `Comparator` (single `compare()` method)
- Java 8 interfaces in `java.util.function` package like `Predicate<T>`, `Function<T, R>`, `Supplier<T>`, etc.

```java
interface Calculator {
    void switchOn();
}

//traditional way
public class Main implements Calculator{

    @Override
    public void switchOn() {
        System.out.println("Turned On");
    }

    public static void main(String args[]) {
        Main obj = new Main();
        obj.switchOn();
    }
}

//using lambda expression
public class Main{
    public static void main(String[] args) {
        //Calculator cal = () -> {System.out.println("Turned On");}
        Calculator cal = () -> System.out.println("Turned On");  //incase of only one statement, we don't need {}
        cal.switchOn();
    }
}
```

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Kate", "Alex" , "Are");
//traditional way + 2
//        LengthComparator lc = new LengthComparator();
//
//        Collections.sort(names, lc);
//
//        System.out.println(names);

//using lambda, does not require tranditional way + 1 as well
        Collections.sort(names, (a,b) -> Integer.compare(a.length(),b.length()));
        System.out.println(names);
    }
}

//traditional way + 1
class LengthComparator implements Comparator<String> {

    @Override
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(),s2.length());
    }
}
```

##### Consumer, Predicate, and Supplier

Consumer, Predicate, and Supplier are some of the most commonly used.

These interfaces enable functional programming and are widely used with lambda expressions, Streams, and method references.

‚∏ª

#### üì¶ 1. Consumer<T>

‚úÖ Purpose:

Represents an operation that takes a single input and returns no result.

‚úÖ Functional Method:
```java
void accept(T t);
```
üß™ Example:
```java
import java.util.function.Consumer;
//traditional way
public class Main implements Consumer<Integer> {
    @Override
    public void accept(Integer i) {
        System.out.println("printing: " + i);
    }

    public static void main(String[] args) {
        Main obj = new Main();
        obj.accept(1);
    }

}

o/p: printing: 1

//lambda
public class Main {

    public static void main(String[] args) {
        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
        consumer.accept(1);
    }

}

o/p: printing: 1
```
#### Note: forEach() as takes consumer and internally uses accept() method
<img width="745" alt="Screenshot 2025-05-24 at 9 36 00‚ÄØPM" src="https://github.com/user-attachments/assets/31058168-4702-4044-9a46-57a1d8db9c04" />

eg:
```java
public class Main {

    public static void main(String[] args) {
//        Consumer<Integer> consumer = i -> System.out.println("printing: "+i);
//        consumer.accept(1);

        List<Integer> list = Arrays.asList(1,2,3,4);
        list.stream().forEach(i -> System.out.println("printing: "+i));
    }

}

o/p:
printing: 1
printing: 2
printing: 3
printing: 4
```

üìù Use Case:

	‚Ä¢	Logging
	‚Ä¢	Printing elements in a list
	‚Ä¢	Performing side effects

‚∏ª

#### ‚úÖ 2. Predicate<T>

‚úÖ Purpose:

Represents a boolean-valued function of one argument. Often used for filtering.

‚úÖ Functional Method:

boolean test(T t);

üß™ Example:
```java
//traditional way
public class Main implements Predicate<Integer> {
    @Override
    public boolean test(Integer integer) {
        return integer % 2 == 0;
    }

    public static void main(String[] args) {
        Main obj = new Main();
        System.out.println(obj.test(4)); //output: true
    }
}

//using lambda
public class Main {

    public static void main(String[] args) {
//        Predicate<Integer> predicate = i -> {
//            return i % 2 == 0;
//        };
        Predicate<Integer> predicate = i -> i%2 == 0;
        System.out.println(predicate.test(5)); //output: false

        //In Java lambda expressions, you can omit the return keyword and curly braces {}
        // when the lambda body contains only a single expression.
        // The expression‚Äôs value is automatically returned.
    }

}
```
#### Note: filter() method of streams accepts predicate as input and internally uses test method
<img width="774" alt="Screenshot 2025-05-24 at 10 10 18‚ÄØPM" src="https://github.com/user-attachments/assets/76e59110-08d1-4f4a-ae5c-9da5bafe2b0e" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Predicate<Integer> predicate = i -> i%2 == 0;
//        System.out.println(predicate.test(5));

        List<Integer> input = Arrays.asList(1,2,3,4);
        input.stream().filter(i -> i%2 == 0)
                .forEach(i -> System.out.println("print even: " + i));

    }

}

output:
print even: 2
print even: 4
```
üìù Use Case:

	‚Ä¢	Filtering collections
	‚Ä¢	Conditional checks

‚∏ª

#### ‚úÖ 3. Supplier<T>

‚úÖ Purpose:

Represents a supplier of results. Takes no input and returns a value.

‚úÖ Functional Method:

T get();

üß™ Example:

```java
//traditional way
public class Main implements Supplier<String> {

    @Override
    public String get() {
        return "hello";
    }

    public static void main(String[] args) {
        //Main obj = new Main();
        Supplier<String> supplier = new Main();
        System.out.println(supplier.get()); //output: hello
    }

}

//lambda
public class Main {

    public static void main(String[] args) {

        Supplier<String> supplier = () -> "hello";
        System.out.println(supplier.get()); //hello
    }
}

```

#### Note: orElseGet of streams internally accepts supplier and users get method
<img width="866" alt="Screenshot 2025-05-24 at 10 27 31‚ÄØPM" src="https://github.com/user-attachments/assets/4a0b745e-f197-4660-9eac-e1c736d43ffd" />

eg:
```java
public class Main {

    public static void main(String[] args) {

//        Supplier<String> supplier = () -> "hello";
//        System.out.println(supplier.get());

        List<String> list = Arrays.asList();
        System.out.println(list.stream().findAny().orElseGet(() -> "hey nothing found in the list"));

    }
}

output:
hey nothing found in the list
```
üìù Use Case:

	‚Ä¢	Lazy initialization
	‚Ä¢	Generating values or objects
	‚Ä¢	Supplying default values

‚∏ª

### üß† 3. Stream API - Definition, Intermediate & Terminal Functions


#### ‚úÖ Stream API ‚Äî Definition

The Stream API (introduced in Java 8) is a feature used to process data in a declarative, functional style.

A Stream:

	‚Ä¢	Is a sequence of elements (like data from a list, set, or array)
	‚Ä¢	Supports functional operations (map, filter, reduce‚Ä¶)
	‚Ä¢	Does not store data ‚Äî it only processes it
	‚Ä¢	Is lazy ‚Äî intermediate operations run only when a terminal operation is called
	‚Ä¢	Can be parallel (for performance)

üí° Think of stream like a pipeline:

Data enters ‚Üí goes through operations ‚Üí gives output.

‚∏ª

‚úÖ Why Use Streams?

	‚Ä¢	Less code
	‚Ä¢	More readable
	‚Ä¢	Functional operations
	‚Ä¢	Easy transformations
	‚Ä¢	Parallel processing support

‚∏ª

‚úÖ Stream API Pipeline Structure

A Stream pipeline has three parts:

	1.	Source (collection/array/IO data)
	2.	Intermediate operations (map/filter/sorted‚Ä¶)
	3.	Terminal operation (collect/forEach/reduce‚Ä¶)

‚∏ª

#### ‚≠ê 1) STREAM CREATION (Source)

Examples:
```java
Stream<Integer> stream = List.of(1, 2, 3).stream();
Stream<String> stream2 = Stream.of("a", "b", "c");
```

‚∏ª

#### ‚≠ê 2) INTERMEDIATE OPERATIONS

These operations return a Stream and are lazy.

They do not execute until a terminal operation is called.

Common Intermediate Operations:

1Ô∏è‚É£ filter()

Filters data based on a condition.
```java
list.stream()
    .filter(n -> n % 2 == 0)
```
2Ô∏è‚É£ map()

Transforms each element.
```java
list.stream()
    .map(n -> n * 2)
```
3Ô∏è‚É£ flatMap()

Flattens nested structures.
```java
listOfLists.stream()
    .flatMap(List::stream)
```
4Ô∏è‚É£ sorted()

Sorts elements.
```java
list.stream().sorted()
```
5Ô∏è‚É£ distinct()

Removes duplicates.
```java
list.stream().distinct()
```
6Ô∏è‚É£ limit() and skip()

Take or skip first N elements.
```java
list.stream().limit(3)
list.stream().skip(2)
```
7Ô∏è‚É£ peek()

Debugging helper.
```java
list.stream().peek(System.out::println)
```

‚∏ª

#### ‚≠ê 3) TERMINAL OPERATIONS

These operations end the stream pipeline and produce a result

(either a single value, a collection, or a side effect).

Common Terminal Operations:

1Ô∏è‚É£ forEach()

Iterates and performs action.
```java
list.stream().forEach(System.out::println);
```
2Ô∏è‚É£ collect()

Converts stream ‚Üí list/set/map.
```java
List<Integer> result = list.stream()
        .filter(n -> n > 10)
        .collect(Collectors.toList());
```
3Ô∏è‚É£ reduce()

Reduces elements to a single result.
```java
int sum = list.stream()
        .reduce(0, (a, b) -> a + b);
```
4Ô∏è‚É£ count()

Counts elements.
```java
list.stream().count();
```
5Ô∏è‚É£ min() / max()
```java
list.stream().max(Integer::compareTo);
```
6Ô∏è‚É£ anyMatch / allMatch / noneMatch

Checks conditions.
```java
list.stream().anyMatch(n -> n > 10);
```
7Ô∏è‚É£ findFirst / findAny
```java
list.stream().findFirst();
```

‚∏ª

üß† Example of Complete Stream Pipeline

Input: [1, 2, 3, 4, 5]

Task: Multiply even numbers by 10 and collect result.
```java
List<Integer> result = List.of(1,2,3,4,5).stream()
        .filter(n -> n % 2 == 0)    // intermediate
        .map(n -> n * 10)           // intermediate
        .collect(Collectors.toList()); // terminal
```
Output:

[20, 40]

‚∏ª

	‚Ä¢	Stream is not a data structure, it‚Äôs a data-processing pipeline.
	‚Ä¢	Intermediate operations are lazy and return Stream.
	‚Ä¢	Terminal operations trigger execution.
	‚Ä¢	Streams can be parallel for performance.
	‚Ä¢	A stream can be used only once (after terminal op it‚Äôs closed).
	‚Ä¢	Supports functional programming in Java.

‚∏ª

### üß† 4. Default & Static Methods in Interfaces

Before Java 8:

	‚Ä¢	Interfaces could only contain abstract methods.
	‚Ä¢	Adding a new method to an interface broke all implementing classes.

Java 8 introduced:

	‚Ä¢	default methods
	‚Ä¢	static methods

to solve these issues and support functional programming.

‚∏ª

#### ‚úÖ 1. DEFAULT METHODS

A default method is a method inside an interface that has a body (implementation).

‚úî Why default methods?

To add new methods to an interface without breaking existing implementations.

Example:
```java
interface Vehicle {
    void start();

    default void honk() {
        System.out.println("Honking...");
    }
}
```
‚úî Key Points:

	‚Ä¢	A class inheriting the interface gets this method automatically.
	‚Ä¢	Implementing class may override it ‚Äî but not required.
	‚Ä¢	Helps maintain backward compatibility.

‚úî Example Usage:
```java
class Car implements Vehicle {
    public void start() {
        System.out.println("Car started");
    }
}

public class Test {
    public static void main(String[] args) {
        Vehicle v = new Car();
        v.honk(); // default method
    }
}
```
‚∏ª

‚ö° When to Use Default Methods?

	‚Ä¢	When you want to provide optional behavior.
	‚Ä¢	When adding a method to an interface used by many classes (to avoid breaking them).
	‚Ä¢	When providing reusable utility logic, but still allowing override.

‚∏ª

#### ‚úÖ 2. STATIC METHODS IN INTERFACES

Static methods in interfaces are similar to static methods in classes ‚Äî but they belong to the interface itself.

‚úî Why static methods?

To provide utility/helper methods related to the interface.

Example:
```java
interface MathUtils {
    static int add(int a, int b) {
        return a + b;
    }
}
```
‚úî How to call them?

int result = MathUtils.add(5, 10); 

‚úî Key Points:

	‚Ä¢	Cannot be overridden by implementing classes.
	‚Ä¢	Cannot be called using an object reference.
```java
MathUtils obj = new MathUtils(); // ‚ùå not allowed
obj.add(1,2);                   // ‚ùå not allowed
```

	‚Ä¢	Must be called using interface name.

‚∏ª

üß† Simple Intuition

	‚Ä¢	default ‚Üí ‚ÄúI will provide a default behavior; classes can use or override it.‚Äù
	‚Ä¢	static ‚Üí ‚ÄúThis is a helper function; it belongs to the interface class itself.‚Äù


‚∏ª

#### ‚úÖ What if your class implements two interfaces having the same default method?

This creates a diamond problem:
Both interfaces offer the same method signature + default implementation.

Example:
```java
interface A {
    default void hello() { System.out.println("Hello from A"); }
}

interface B {
    default void hello() { System.out.println("Hello from B"); }
}

class C implements A, B {
}
```

üëâ This does NOT compile.

Java doesn‚Äôt know which default method to inherit.

‚ùóCompiler Error:

class C inherits unrelated defaults for hello() from A and B


‚∏ª

#### How to solve it?

You must override the method in your class and choose which interface‚Äôs method you want.
```java
class C implements A, B {
    @Override
    public void hello() {
        A.super.hello(); // Calling Interface A's default method
        // OR
        // B.super.hello();
    }
}
```

‚∏ª

#### How to call the method in Interface A inside implementing class?

Use:
```java
A.super.methodName();
```
Example:
```java
class C implements A, B {
    @Override
    public void hello() {
        A.super.hello();   // Calls A's default method
    }
}
```

‚∏ª

#### Why can‚Äôt you call a default method directly in main?

Because:

‚úî Default methods belong to objects, not to the interface type.

You must always call them through an instance, not via interface name.

Example (not allowed):
```java
A.hello();  // ‚ùå Compile error
```
Error:

Non-static method hello() cannot be referenced from a static context

‚úî Why?

Because default methods are essentially instance methods, added to the class that implements the interface.

‚úî Correct way:
```java
A obj = new C();
obj.hello();  // ‚úî works
```

‚∏ª

Purpose	Add new behavior without breaking old code	Utility/helper methods

‚úî Two interfaces with same default method?

Implementing class must override and choose explicitly.

‚úî Call interface-specific default method?

InterfaceName.super.methodName();

‚úî Why you can‚Äôt call default method from main using interface name?

Because default methods are instance methods, not static methods.

‚∏ª


### üß† 5. Optional Class

Purpose:

To handle null values safely without NullPointerException.

Example:
```
		Optional<String> name = Optional.ofNullable(null);
		System.out.println(name.orElse("Default Name")); //Default Name
		name.ifPresent(System.out::println); // does not execute
		System.out.println(name.orElse("nothing"));  //nothing

        Optional<String> name = Optional.ofNullable("Kate");
        System.out.println(name.isPresent()); // true 

        System.out.println(name.orElse("nothing"));  //Kate

        name.ifPresent(System.out::println); //Kate
```
Common Methods:

	‚Ä¢	isPresent() ‚Üí check value presence
	‚Ä¢	orElse() ‚Üí provide default
	‚Ä¢	ifPresent() ‚Üí run code if not null

‚úÖ Benefits

	‚Ä¢	Null-safe code
	‚Ä¢	Improves readability

‚∏ª

### üß† 6. New Date and Time API (java.time)

Replaces Date and Calendar with immutable, thread-safe, and easy-to-use classes.

Example:
```
import java.time.*;

LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(2000, Month.JUNE, 15);

Period age = Period.between(birthday, today);
System.out.println("Age: " + age.getYears());
```
Main Classes:

	‚Ä¢	LocalDate, LocalTime, LocalDateTime
	‚Ä¢	Period, Duration
	‚Ä¢	ZonedDateTime

‚úÖ Benefits

	‚Ä¢	Easier to format and manipulate
	‚Ä¢	Immutable and thread-safe

‚∏ª

### üß† 7. Method References

Definition:

Shortcut for lambda expressions that call existing methods.

Example:
```java
List<String> names = Arrays.asList("Kate", "Yashwanth", "Arelli");

// Lambda
names.forEach(n -> System.out.println(n));

// Method reference
names.forEach(System.out::println);
```
Types of References:

	‚Ä¢	Class::staticMethod
	‚Ä¢	object::instanceMethod
	‚Ä¢	Class::new (constructor reference)

‚∏ª

### üß† 8. Parallel Streams

Definition:

Runs stream operations in multiple threads to increase performance on large data sets.

Example:
```java
List<Integer> numbers = IntStream.rangeClosed(1, 1000000)
                                 .boxed()
                                 .collect(Collectors.toList());

long sum = numbers.parallelStream()
                  .mapToLong(i -> i)
                  .sum();

System.out.println(sum);
```
‚ö†Ô∏è Use carefully:

Parallel processing overhead can reduce performance for small datasets.

‚∏ª

üßæ Summary Table

Feature					Purpose											Example
Lambda					Write concise code								(x) -> x * 2
Functional Interface	Enable lambdas									@FunctionalInterface
Stream API				Process collections easily						stream().filter()
Default/Static Methods	Extend interfaces								default void print()
Optional				Handle nulls safely								Optional.ofNullable()
Date & Time API			Modern date handling							LocalDate.now()
Method Reference		Simplify lambdas								System.out::println
Parallel Streams		Multi-threaded data ops							parallelStream()
Nashorn	Run JavaScript	engine.eval("JS")

‚∏ª

# 2. Exception Hierarchy
```
java.lang.Object
     ‚Üì
  Throwable
   ‚îú‚îÄ‚îÄ Error (unchecked)
   ‚îÇ      ‚îú‚îÄ‚îÄ OutOfMemoryError
   ‚îÇ      ‚îú‚îÄ‚îÄ StackOverflowError
   ‚îÇ      ‚îî‚îÄ‚îÄ etc...
   ‚îî‚îÄ‚îÄ Exception
          ‚îú‚îÄ‚îÄ RuntimeException (unchecked)
          ‚îÇ       ‚îú‚îÄ‚îÄ NullPointerException
          ‚îÇ       ‚îú‚îÄ‚îÄ ArithmeticException
          ‚îÇ       ‚îú‚îÄ‚îÄ IllegalArgumentException
          ‚îÇ       ‚îî‚îÄ‚îÄ ArrayIndexOutOfBoundsException
          ‚îî‚îÄ‚îÄ Checked Exceptions
                  ‚îú‚îÄ‚îÄ IOException
                  ‚îú‚îÄ‚îÄ SQLException
                  ‚îú‚îÄ‚îÄ ParseException
                  ‚îî‚îÄ‚îÄ ClassNotFoundException
```

- Exception hierarchy starts from Throwable class.

- Throwable has two children: Error and Exception.

- Errors are unrecoverable and represent issues outside application control.

- Exceptions are recoverable and divided into 

1. Checked exceptions (must be handled) 

These are exceptions that the compiler forces you to handle.

You MUST either:

	‚Ä¢	use try-catch
	‚Ä¢	or throws in method signature

Examples:

	‚Ä¢	IOException
	‚Ä¢	SQLException
	‚Ä¢	FileNotFoundException
	‚Ä¢	ClassNotFoundException


2. Unchecked exceptions (RuntimeException).

These happen during execution due to programming errors. Compiler does NOT force you to catch them.

Examples:

	‚Ä¢	NullPointerException
	‚Ä¢	ArithmeticException
	‚Ä¢	ArrayIndexOutOfBoundsException
	‚Ä¢	IllegalArgumentException
	‚Ä¢	ClassCastException


‚∏ª

‚≠ê 1. try

The try block contains code that might throw an exception.
```java
try {
    riskyCode();
}
```
Purpose:

‚úî Detect errors at runtime
‚úî Prevent application crash
‚úî Transfer control to a catch/finally block

‚∏ª

‚≠ê 2. catch

The catch block handles the exception thrown inside the try block.
```java
catch(Exception e) {
    System.out.println(e.getMessage());
}
```
Purpose:

‚úî Handle the error
‚úî Recover or show meaningful message
‚úî Log the issue

You can have:

	‚Ä¢	Multiple catch blocks
	‚Ä¢	Catching specific exceptions first (most specific ‚Üí most general)

‚∏ª

‚≠ê 3. finally

The finally block executes always, whether exception occurs or not.
```java
finally {
    closeResources();
}
```
Runs in:
‚úî Normal execution
‚úî Exception thrown
‚úî Exception handled
‚úî Exception not handled
‚úî Even after return statement inside try/catch

Purpose:
‚úî Clean-up code
‚úî Closing files/DB connections
‚úî Releasing resources

‚∏ª

‚≠ê 4. throw

throw is used to explicitly throw an exception inside code.

throw new IllegalArgumentException("Invalid input");

Uses:

	‚Ä¢	For custom validations
	‚Ä¢	Manual exceptions
	‚Ä¢	Business rule violations

Example:
```java
if(age < 18) {
    throw new RuntimeException("Not allowed");
}
```

‚∏ª

‚≠ê 5. throws

throws is used in method declaration to say:

‚ÄúThis method may throw an exception ‚Äî caller must handle it.‚Äù
```java
void readFile() throws IOException {
    // risky code
}
```
It does not throw exception.

It just declares the possibility.

Used mainly for:

‚úî Checked exceptions
‚úî Declaring contract for caller

‚∏ª

## Custom Exceptions

A custom exception is a user-defined exception that helps represent business-specific errors more clearly.
We create custom checked exceptions by extending Exception and custom unchecked exceptions by extending RuntimeException.‚Äù


A custom exception is an exception you define yourself when Java‚Äôs built-in exceptions are not enough for your business logic.

For example:

	‚Ä¢	‚ÄúInsufficientBalanceException‚Äù
	‚Ä¢	‚ÄúInvalidAgeException‚Äù
	‚Ä¢	‚ÄúUnauthorizedUserException‚Äù
	‚Ä¢	‚ÄúOrderNotFoundException‚Äù

They make your code more meaningful, readable, and domain-specific.

‚∏ª

üü¶ Types of Custom Exceptions

You can create:

1Ô∏è‚É£ Custom Checked Exceptions

Extend Exception.

2Ô∏è‚É£ Custom Unchecked Exceptions

Extend RuntimeException.

‚∏ª

üü¶ 1. Custom Checked Exception

üëâ Use when caller must handle the exception

(either try-catch or throws)

Example: InvalidAgeException
```java
class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}

//Use it:

public void register(int age) throws InvalidAgeException {
    if (age < 18) {
        throw new InvalidAgeException("Age must be 18 or above");
    }
}
```

‚∏ª

üü© 2. Custom Unchecked Exception

üëâ Use when the exception is caused by programming errors

(no need to force try-catch)

Extend RuntimeException.
```java
class InsufficientBalanceException extends RuntimeException {
    public InsufficientBalanceException(String message) {
        super(message);
    }
}

//Use it:

public void withdraw(double amount) {
    if (amount > balance) {
        throw new InsufficientBalanceException("Not enough balance");
    }
}
```

‚∏ª

üüß Checked vs Unchecked Custom Exceptions
```
Type Extend			Must be caught?		When to use
Checked	Exception	Yes (compile-time)	Expected business rule failures
Unchecked			RuntimeException	No	Code bugs, invalid input, illegal states
```

‚∏ª

## Why do we need to use super(message); in custom exceptions?


Because Exception, RuntimeException, and Throwable (the parent classes) already have a constructor that accepts an error message.

Example from Java source:
```java
public Throwable(String message) {
    this.detailMessage = message;
}
```
So when you write:

super(message);

You are sending your custom message up to the parent class, so that:

‚úî The exception stores the message

‚úî The message appears in the logs

‚úî getMessage() returns your message

‚úî Stack trace shows helpful information

‚∏ª

üü¶ Without super(message) ‚Äî the exception message becomes NULL

Example:
```
class MyException extends RuntimeException {
    public MyException() {
        // NO super(message)
    }
}
```
Using it:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: null
```
‚ùå No message
‚ùå Hard to debug
‚ùå Useless in logs and monitoring

‚∏ª

üü© With super(message) ‚Äî message is preserved
```java
class MyException extends RuntimeException {
    public MyException(String message) {
        super(message);
    }
}
```
Now:
```java
throw new MyException("Something went wrong");
```
Output:
```
MyException: Something went wrong
```
‚úî Message is visible
‚úî Debugging becomes easy
‚úî Logs become meaningful

‚∏ª

We use super(message) to pass our custom error message to the parent Exception class. This allows the exception to store the message, display it in the stack trace, and retrieve it through getMessage(). Without it, the message will be lost.

‚∏ª

üî• Bonus: super(cause) and super(message, cause)

Exception classes allow:
```java
super(cause);           // chain exception
super(message, cause);  // message + root cause
```
These help track real underlying failures.

---------------

# 3. try-with-resources

try-with-resources is a Java feature that automatically closes resources (like files, DB connections, sockets, streams) after their usage ‚Äî without requiring a finally block.

A resource is anything that implements the interface:

AutoCloseable


‚∏ª

üö´ Old way (before Java 7): Manual closing

Using a file:
```java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader("data.txt"));
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
} finally {
    try {
        if (br != null) br.close();   // must close manually
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
Problems:

‚ùå Long code
‚ùå Easy to forget closing
‚ùå Possible memory/resource leaks

‚∏ª

‚úÖ New way (after Java 7): try-with-resources
```java
try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    System.out.println(br.readLine());
} catch (IOException e) {
    e.printStackTrace();
}
```
Advantages:

‚úî Resource automatically closed
‚úî No need for finally block
‚úî Cleaner code
‚úî Prevents resource leaks
‚úî More readable

‚∏ª

üß† How it works internally?

At the end of the try block, Java automatically calls:
```java
br.close();
``
* because BufferedReader implements:
```
public interface Closeable extends AutoCloseable
```
* So anything implementing AutoCloseable works with try-with-resources.

‚∏ª

‚ÄúTry-with-resources is a Java feature that automatically closes resources at the end of a try block. Any class implementing AutoCloseable can be used. This avoids memory leaks and makes code cleaner compared to the old try-catch-finally approach.‚Äù

‚∏ª

‚≠ê Extra imp Points

1. Resources are closed in reverse order

Last opened ‚Üí closed first.

2. Works with custom resources

You can create your own class:
```java
class MyResource implements AutoCloseable {
    @Override
    public void close() {
        System.out.println("Closed automatically");
    }
}
```
Then:
```java
try (MyResource r = new MyResource()) {
    // use resource
}
```
3. Finally block is not required

4. Less error-prone ‚Üí prevents resource leaks

‚∏ª

### Controller Advice, Rest Controller Advice, Exception Handler


üåü 1. @ControllerAdvice

‚úî What is it?

@ControllerAdvice is a global exception-handling mechanism in Spring MVC.

Think of it as a central place where:

	‚Ä¢	You handle exceptions for all controllers
	‚Ä¢	You write common error-handling logic
	‚Ä¢	You avoid repeating try/catch in every controller

‚úî Key Point:

It works for:

	‚Ä¢	@Controller
	‚Ä¢	@RestController

‚úî Example:
```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(NullPointerException.class)
    public String handleNullPointer(NullPointerException ex) {
        return "error-page";   // returns view name
    }
}
```
üí° @ControllerAdvice is usually used in MVC apps that return views (HTML/JSP).

‚∏ª

üåü 2. @RestControllerAdvice

‚úî What is it?

@RestControllerAdvice = @ControllerAdvice + @ResponseBody

Meaning:

	‚Ä¢	Returns JSON responses
	‚Ä¢	Used in REST APIs

‚úî Example:
```java
@RestControllerAdvice
public class RestGlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ErrorResponse handleIllegalArgument(IllegalArgumentException ex) {

        return new ErrorResponse("INVALID_INPUT", ex.getMessage());
    }
}
```
üí° Use this in REST microservices built with Spring Boot.

‚∏ª

üåü 3. @ExceptionHandler

‚úî What is it?

@ExceptionHandler is used inside a Controller or inside ControllerAdvice to handle specific exceptions.

It tells Spring:

‚ÄúWhenever this exception occurs, call this method.‚Äù

‚úî Example inside @RestControllerAdvice:
```java
@ExceptionHandler(ResourceNotFoundException.class)
public ResponseEntity<?> handleResourceNotFound(ResourceNotFoundException ex) {
    return ResponseEntity.status(404).body(ex.getMessage());
}
```
‚úî It can handle:

	‚Ä¢	One exception
	‚Ä¢	Multiple exceptions
```java
@ExceptionHandler({NullPointerException.class, IllegalStateException.class})
```

‚∏ª

‚≠ê How They Work Together (Big Picture)
```
Controller throws exception

‚¨á
Spring searches for local @ExceptionHandler
‚¨á
If not found ‚Üí checks @ControllerAdvice / @RestControllerAdvice
‚¨á
Returns response
```
‚∏ª

‚≠ê Quick Summary Table
```
Annotation					Type			Used For						Returns	Best 		Use Case
@ControllerAdvice			Global			MVC Controllers					View (HTML)			Web apps
@RestControllerAdvice		Global			REST Controllers				JSON				REST APIs / Microservices
@ExceptionHandler			Local or Global	Handling specific exceptions	View or JSON		Business exceptions
```

‚∏ª

üåü Full Working Example (REST API)

üéØ Controller
```java
@RestController
public class UserController {

    @GetMapping("/user/{id}")
    public String getUser(@PathVariable int id) {
        if(id <= 0) {
            throw new IllegalArgumentException("Invalid user id");
        }
        return "User found";
    }
}
```

‚∏ª

üéØ Global Exception Handler
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegal(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body(ex.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleOther(Exception ex) {
        return ResponseEntity.status(500).body("Something went wrong");
    }
}
```

‚∏ª

üåü Output
```
Call: /user/-1
Response:

Invalid user id
```

‚∏ª
```
To avoid writing repetitive try/catch inside controllers.

It gives a common, centralized place to handle exceptions and improve code cleanliness.
```

‚∏ª


# Sealed Classes in Java

Sealed classes (introduced in Java 17) allow you to control which classes are allowed to extend or implement a class or interface.

Think of it like saying:

‚ÄúOnly these specific subclasses are allowed. No one else can extend me.‚Äù

This gives:

	‚Ä¢	Better control over inheritance
	‚Ä¢	More secure and predictable class hierarchies
	‚Ä¢	Helps the compiler perform better exhaustiveness checks (like switch-expressions)

‚∏ª

‚úÖ Why do we need Sealed Classes?

Because normal inheritance is too open:

class A {}

Anyone can extend class A.

With sealed classes, you restrict this:

sealed class A permits B, C {}

Now only B and C can extend A.


‚∏ª

‚úÖ Syntax of Sealed Classes

1. Declaring a sealed class
```java
public sealed class Vehicle permits Car, Bike {}
```
2. Subclasses must choose exactly one of:
   
	‚Ä¢	final ‚Üí cannot be extended further
	‚Ä¢	sealed ‚Üí can further restrict its children
	‚Ä¢	non-sealed ‚Üí open for extension

Example:
```java
public final class Car extends Vehicle {}        // no further extension allowed
public non-sealed class Bike extends Vehicle {}  // others can extend Bike
```
‚∏ª

‚ùå Common Misconceptions

‚ùå ‚ÄúSealed class means it cannot be extended.‚Äù

No.

It can be extended ‚Äî but only by permitted subclasses.

‚ùå ‚ÄúSealed is same as final.‚Äù

No.

final = no one can extend

sealed = some can extend

non-sealed = anyone can extend


A sealed class restricts which classes can extend or implement it. Its child classes must explicitly choose to be final, sealed, or non-sealed. It ensures controlled inheritance and helps the compiler with pattern matching.

‚∏ª

# Serialization vs Deserialization

üåü Serialization vs Deserialization (Simple Definition)
```
Concept				Meaning										Direction
Serialization		Converting a Java object ‚Üí byte stream		Object ‚ûù Bytes
Deserialization		Converting a byte stream ‚Üí Java object		Bytes ‚ûù Object
```

‚∏ª

üåü 1. What is Serialization?

Serialization is the process of converting a Java object into a byte stream so that it can be:

‚úî Saved to a file

‚úî Sent over a network

‚úî Stored in a database

‚úî Placed in cache (Redis, Kafka messages, etc.)

How to enable serialization?

A class must implement:
```java
class Employee implements Serializable {
    private String name;
    private int id;
}
```
Example:
```java
FileOutputStream fos = new FileOutputStream("data.ser");
ObjectOutputStream oos = new ObjectOutputStream(fos);

Employee e = new Employee("John", 101);
oos.writeObject(e);  // Serialization

oos.close();
```

‚∏ª

üåü 2. What is Deserialization?

Deserialization is converting the byte stream back into the original Java object.

Example:
```
FileInputStream fis = new FileInputStream("data.ser");
ObjectInputStream ois = new ObjectInputStream(fis);

Employee e = (Employee) ois.readObject();  // Deserialization

ois.close();
```

‚∏ª

Serialization is saving an object as bytes.

Deserialization is reconstructing the object from those bytes.

‚∏ª

üåü Real-World Examples

‚úî 1. REST APIs

Jackson automatically serializes Java objects ‚Üí JSON.

And deserializes JSON ‚Üí Java objects.

‚úî 2. Kafka messages

Producer serializes object ‚Üí bytes ‚Üí sends.

Consumer deserializes bytes ‚Üí object.

‚úî 3. Hibernate

Entities are serialized when going into cache (level 2 cache).

‚úî 4. Microservices

Objects shared between services over network are serialized as JSON/Avro.

‚∏ª

### üîπ Why is Serialization needed?

Because objects cannot travel over network or be saved as they are. Only bytes can.

### üîπ What happens if you don‚Äôt implement Serializable?

NotSerializableException.

### üîπ What is serialVersionUID?

A unique ID used for versioning during deserialization.

‚∏ª

üåü Final Comparison Table
```
Feature		Serialization				Deserialization
Purpose		Convert object ‚Üí bytes		Convert bytes ‚Üí object
Method		writeObject()				readObject()
Required 	Class						Implements Serializable	Same class must exist
Format		Binary or JSON/Avro/XML		Reconstructs original object
```

‚∏ª

## Transient

üåü What is transient in Java?

transient is a keyword used to indicate that a field should NOT be serialized.

Meaning:

üëâ When you convert an object ‚Üí bytes (Serialization),

transient fields are skipped and their values are not saved.

‚∏ª

üåü Why do we need transient?

Because some fields:

	‚Ä¢	Should NOT be stored
	‚Ä¢	Should NOT be sent across network
	‚Ä¢	Are sensitive or temporary

Examples:

‚úî passwords
‚úî OTPs
‚úî cache-like values
‚úî large objects that shouldn‚Äôt be serialized
‚úî computed values

‚∏ª

üåü Example
```java
class User implements Serializable {
    String username;
    transient String password;   // will NOT be serialized
}
```
Serialization:
```java
User u = new User("Kate", "secret123");
oos.writeObject(u);
```
Deserialization:
```java
User u = (User) ois.readObject();
```
Output:

	‚Ä¢	username: ‚ÄúKate‚Äù
	‚Ä¢	password: null (because it was transient)

‚∏ª

üåü Important Points

###  1. transient only affects Serialization

Not encryption, not hiding ‚Äî only Java serialization.

### 2. If a field is transient, during deserialization:

	‚Ä¢	primitives ‚Üí get default values
	‚Ä¢	int ‚Üí 0
	‚Ä¢	boolean ‚Üí false
	‚Ä¢	objects ‚Üí null

###‚úî 3. transient + static = always skipped

Static fields never belong to an object ‚Üí automatically not serialized.

###‚úî 4. Used in frameworks

	‚Ä¢	Hibernate: avoids serializing lazy-loaded fields
	‚Ä¢	Spring Boot: avoids serializing internal objects
	‚Ä¢	Kafka: avoid serializing unnecessary fields

‚∏ª

üåü Real-World Example
```java
class Employee implements Serializable {
    private String name;
    private transient int pinCode; // sensitive
}
```
When sending Employee object through REST API, Kafka, Redis, or writing to file:

‚úî name is serialized

‚ùå pinCode is not serialized

‚∏ª

Summary

transient is a keyword used to tell Java not to serialize that field.
During serialization it is ignored; during deserialization it becomes default value (null/0/false).
It is used for sensitive, temporary, or unnecessary fields.

‚∏ª


# Shallow vs Deep Copy

üåü What is Shallow Copy?

A shallow copy copies only the top-level object,
NOT the nested (referenced) objects.

That means:

	‚Ä¢	Primitive fields ‚Üí copied
	‚Ä¢	Object fields ‚Üí only reference copied
	
(both original and copied objects point to same inner object)

‚úî Effects:

Changing inner object in copy will affect the original.

‚úî Example (Shallow Copy):
```
class Address {
    String city;
    Address(String city) { this.city = city; }
}

class Person implements Cloneable {
    String name;
    Address address;

    Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // Performs a shallow copy by default
    }
}

public class ShallowCopyExample {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address originalAddress = new Address("New York");
        Person originalPerson = new Person("Alice", originalAddress);

        Person copiedPerson = (Person) originalPerson.clone();

        // Modifying the address in the copied object
        copiedPerson.address.city = "London";

        System.out.println("Original Person's Address: " + originalPerson.address.city); // Output: London
        System.out.println("Copied Person's Address: " + copiedPerson.address.city);   // Output: London
    }
}
```

Because both share same Address object.

‚∏ª

üåü What is Deep Copy?

A deep copy copies:

	‚Ä¢	the top-level object
	‚Ä¢	AND all nested (reference) objects recursively

Deep copy = Completely independent object.

‚úî Effects:

Changing inner object in copy does not affect original.

‚úî Example (Deep Copy):
```java
class Address {
    String city;
    Address(String city) { this.city = city; }
    // Copy constructor for Address
    Address(Address other) { this.city = other.city; }
}

class Person {
    String name;
    Address address;

    Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    // Copy constructor for Person
    Person(Person other) {
        this.name = other.name;
        this.address = new Address(other.address); // Deep copy of Address
    }
}

public class DeepCopyExample {
    public static void main(String[] args) {
        Address originalAddress = new Address("New York");
        Person originalPerson = new Person("Alice", originalAddress);

        Person copiedPerson = new Person(originalPerson); // Using copy constructor

        // Modifying the address in the copied object
        copiedPerson.address.city = "London";

        System.out.println("Original Person's Address: " + originalPerson.address.city); // Output: New York
        System.out.println("Copied Person's Address: " + copiedPerson.address.city);   // Output: London
    }
}
```
They have separate Address objects.

‚∏ª

üåü Simple Explanation

Shallow copy copies only the object but not the objects referenced inside it.
Both original and copied object share same inner objects.

Deep copy copies everything including nested objects, so the copy is fully independent.

‚∏ª

# Multithreading

Multi-threading is a programming concept that allows multiple threads to run concurrently within a single program.

It is essential for improving the performance and responsiveness of applications.

‚∏ª

# ‚úÖ 1. What is a Thread?

A thread is the smallest unit of execution inside a process.

A Java program always has at least one thread:

‚úî main thread (created automatically by JVM).

We create additional threads to do tasks in parallel.

Threads help when:

	‚Ä¢	Doing background tasks
	‚Ä¢	Performing I/O operations
	‚Ä¢	Running periodic tasks
	‚Ä¢	Improving performance with concurrency

‚∏ª

# ‚úÖ 2. Thread Creation in Java

There are three main ways to create a thread:

‚∏ª

### A. Extending Thread class

‚úî Simple

‚úò Not flexible (can‚Äôt extend any other class)

‚∏ª

### B. Implementing Runnable

‚úî Preferred method

‚úî Reusable and more flexible

‚úî Task (Runnable) is separated from Thread

‚∏ª

### C. Using Lambda (shorter form)

### D. Using ExecutorService (Thread Pool)

For professional applications, we use ExecutorService to manage threads efficiently.

üí° Why This Is Preferred: 

‚Ä¢ Reuses threads (avoids overhead of creating new ones each time) 
‚Ä¢ Easier to manage many tasks 
‚Ä¢ Common in enterprise and Spring Boot applications

Single Example:

```java
public class ThreadsExample {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("running inside main thread: " + Thread.currentThread().getName());
        ThreadA a = new ThreadA();
        a.start();

        Thread b = new Thread(new ThreadB());
        b.start();

        Thread c = new Thread(
                () -> System.out.println("inside lambda thread: " + Thread.currentThread().getName())
        );
        c.start();

        ExecutorService service = Executors.newFixedThreadPool(2);
        service.submit(() -> System.out.println("inside executor service"));

        //Daemon thread
        Thread d = new Thread(
                () -> System.out.println("inside daemon thread: " + Thread.currentThread().getName())
        );
        d.setDaemon(true);
        d.start();
        //by default JVM will not wait for this thread to finish, to make it wait
        d.join();  // waits for daemon to finish, Now JVM will wait.
    }
}

class ThreadA extends Thread {

    @Override
    public void run() {
        System.out.println("thread running via extending thread: " + Thread.currentThread().getName());
    }
}

class ThreadB implements Runnable {

    @Override
    public void run() {
        System.out.println("thread running via implementing runnable: "+ Thread.currentThread().getName());
    }
}
```

### Extra: user threads vs daemon threads

User Threads:

Keep the JVM running.

The program will not terminate until all user threads finish executing.

Daemon Threads:

Serve as background tasks.

Do not prevent the JVM from exiting when all user threads are done.

JVM can terminate once all the user threads are finished executing even though still demon threads are present and executing a logic



‚∏ª

# ‚úÖ 3. start() vs run()

### run()

	‚Ä¢	Just a normal method
	‚Ä¢	If you call it directly ‚Üí NO new thread is created
```java
t.run();   // runs in main thread
```
### start()
	‚Ä¢	Creates a new thread
	‚Ä¢	JVM calls the run() method internally in that new thread
```java
t.start(); // new thread is created
```
Simple Example

Thread t = new Thread(() -> System.out.println(Thread.currentThread().getName()));
```java
t.run();   // prints: main   (no new thread)
t.start(); // prints: Thread-0 (new thread)
```
üëâ Important: Always use start() to create actual multithreading.

‚∏ª

# ‚úÖ 4. Thread Life Cycle

Threads in Java go through 6 states according to Thread.State enum.

‚úî Thread States:
```
NEW ‚Üí RUNNABLE ‚Üí BLOCKED/WAITING/TIMED_WAITING ‚Üí RUNNABLE ‚Üí TERMINATED
```

States:

New: Thread created but start() not called.

Runnable: Thread is ready to run OR currently running on CPU.

Blocked/ Waiting / Timed Waiting: Thread is waiting to acquire a lock / Thread is waiting indefinitely for another thread to complete some action. / Thread waits for a specific time.

Terminated: Thread has completed execution.

# Race conditions

A race condition happens when two or more threads access shared data at the same time, and the final result depends on the order of execution ‚Äî which is unpredictable.

This leads to incorrect, inconsistent, or unexpected outcomes.

To fix race conditions, we must use:

	‚Ä¢	synchronized,
	‚Ä¢	locks, or
	‚Ä¢	atomic classes.

# Synchronization

Synchronization in Java is a mechanism to ensure that only one thread accesses a shared resource at a time.

Why?

To prevent race conditions and inconsistent data when multiple threads read/write shared data.


‚úî ONLY one thread to enter a critical section at a time

‚úî Other threads must wait

‚∏ª

‚úÖ Types of Synchronization (High Level)

	1.	Method-level synchronization
	2.	Block-level synchronization
	3.	Static synchronization
	
‚∏ª

### 1Ô∏è‚É£ Method-level Synchronization

A. Synchronized Instance Method
```java
public synchronized void updateBalance() {
    // critical section
}
```
Meaning:

	‚Ä¢	Lock is applied on the current object (this)
	‚Ä¢	Only one thread per object instance can access it at a time

üîí What object is locked?

The object instance ‚Üí this

‚∏ª

### 2Ô∏è‚É£ Block-level Synchronization (Most Used)
```java
public void updateBalance() {
    synchronized(this) {
        // critical section
    }
}
```
What is locked? ‚Üí this

Same effect as a synchronized method but allows finer control.

You can also synchronize on any shared object:

private final Object lock = new Object();

synchronized(lock) {
    // thread-safe work
}


‚∏ª

### 3Ô∏è‚É£ Static Synchronization
```java
public static synchronized void log() {
    // critical section
}
```
What object is locked?

‚úî Class object, i.e., ClassName.class

Meaning:

	‚Ä¢	Only one thread across all instances can access this method

‚∏ª

### üßµ How synchronized actually works (step-by-step)

When a thread enters a synchronized block:
```
	1.	Thread tries to acquire the lock on the object
	2.	If lock is free ‚Üí thread gets it and enters
	3.	If lock is held ‚Üí thread moves to BLOCKED state
	4.	When lock is released, next thread gets a chance
```
‚∏ª

üõ† Important: synchronized gives 3 guarantees
```
Feature																	Provided?
Mutual exclusion (one thread at a time)									‚úî Yes
Visible memory updates between threads									‚úî Yes
Atomicity (an operation that happens completely or not at all)			‚úî Yes (for critical section)
```

‚∏ª

üß© When to use block vs method synchronization?
```
Case							Use
Protect entire method			synchronized method
Protect only small part			synchronized block (more efficient)
Protect class-level data		static synchronized
Need custom lock object			synchronized(lockObject)
```

‚∏ª

### üß® Problems with synchronized

	‚Ä¢	Can cause deadlocks
	‚Ä¢	Thread is BLOCKED ‚Üí no timeout available
	‚Ä¢	Hard to debug
	‚Ä¢	Can reduce performance heavily with heavy contention

This is why modern code often uses:

‚úî ReentrantLock
‚úî AtomicInteger
‚úî ConcurrentHashMap
‚úî Semaphore

‚∏ª

### üöÄ Thread.sleep()

‚úÖ What it does

	‚Ä¢	Pauses the current thread for a given time.
	‚Ä¢	Thread moves to TIMED_WAITING state.
	‚Ä¢	Does NOT release any lock.
	‚Ä¢	Simply a delay.
```java
Thread.sleep(1000); // sleep 1 second
```

‚∏ª

# wait(), notify(), and notifyAll() in Java?

These are methods used for thread communication, i.e. for threads to coordinate their work.

They belong to the Object class, not the Thread class ‚Äî meaning every object in Java can be used as a lock for thread communication.

‚∏ª

üí° Real-Life Analogy

Imagine a restaurant üçΩÔ∏è:

	‚Ä¢	A chef thread prepares food.
	‚Ä¢	A waiter thread serves it.

The waiter can‚Äôt serve until the chef finishes cooking.

So the waiter waits, and when the chef is done, he notifies the waiter.

That‚Äôs what wait() and notify() do.

‚∏ª

‚öôÔ∏è The Three Methods

### 1Ô∏è‚É£ wait()

	‚Ä¢	The current thread pauses execution and releases the lock on the object.
	‚Ä¢	The thread goes into the waiting state.
	‚Ä¢	It waits until another thread calls notify() or notifyAll() on the same object.
```java
synchronized (sharedObject) {
    sharedObject.wait(); // releases the lock and waits
}
```

‚∏ª

### 2Ô∏è‚É£ notify()

	‚Ä¢	Wakes up one thread that‚Äôs waiting on the same object.
	‚Ä¢	But it doesn‚Äôt decide which thread ‚Äî the choice is JVM‚Äôs.
	‚Ä¢	The awakened thread must reacquire the lock before it can continue.
```java
synchronized (sharedObject) {
    sharedObject.notify(); // wakes up one waiting thread
}
```

‚∏ª

### 3Ô∏è‚É£ notifyAll()

	‚Ä¢	Wakes up all threads waiting on the same object.
	‚Ä¢	They all move to the runnable state, but only one thread at a time can reacquire the lock and continue.
```java
synchronized (sharedObject) {
    sharedObject.notifyAll(); // wakes up all waiting threads
}
```

‚∏ª

üß† Example ‚Äî Producer-Consumer Problem

. It demonstrates how two threads communicate safely when they share the same data.


Let‚Äôs simulate a simple queue shared between two threads:

	‚Ä¢	Producer adds items.
	‚Ä¢	Consumer removes items.
	
```java
class SharedQueue {
    private int data;
    private boolean hasData = false;

    public synchronized void produce(int value) throws InterruptedException {
        while (hasData) {
            wait(); // wait until data is consumed
        }
        data = value;
        hasData = true;
        System.out.println("Produced: " + data);
        notify(); // wake up consumer
    }

    public synchronized void consume() throws InterruptedException {
        while (!hasData) {
            wait(); // wait until data is produced
        }
        System.out.println("Consumed: " + data);
        hasData = false;
        notify(); // wake up producer
    }
}

public class WaitNotifyExample {
    public static void main(String[] args) {
        SharedQueue queue = new SharedQueue();

        Thread producer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                try { queue.produce(i); } catch (InterruptedException e) {}
            }
        });

        Thread consumer = new Thread(() -> {
            for (int i = 1; i <= 5; i++) {
                try { queue.consume(); } catch (InterruptedException e) {}
            }
        });

        producer.start();
        consumer.start();
    }
}
```

‚∏ª

üß© Important Rules
```
Concept							Description
Where to call					Inside a synchronized block only
What happens during wait()		Thread releases lock and waits
What happens during notify()	Wakes one waiting thread, doesn‚Äôt release lock immediately
notifyAll()						Wakes all waiting threads
Without synchronization			Throws IllegalMonitorStateException
```

‚∏ª

‚ö†Ô∏è Common Mistake

Calling wait() or notify() without synchronization:

sharedObject.wait(); // ‚ùå IllegalMonitorStateException

‚úÖ Correct usage:
```java
synchronized (sharedObject) {
    sharedObject.wait();
}
```

‚∏ª

üß† Easy way to remember
```
Method		Thread Action	Releases Lock?	Who Wakes Up?
wait()		Go to sleep		‚úÖ Yes	‚Äî
notify()	Wake up one		‚ùå No (until synchronized block ends)	One thread
notifyAll()	Wake up all		‚ùå No (until synchronized block ends)	All threads
```

‚∏ª

# üîπ 1. Thread.join()

‚úÖ What it does:

	‚Ä¢	join() tells the current thread to wait for another thread to finish before continuing.

‚úÖ Why it‚Äôs useful:

	‚Ä¢	Useful when one thread depends on the result of another.
	‚Ä¢	Ensures sequential execution in multithreaded programs when needed.

üß† Syntax:

thread.join();      // Waits indefinitely
thread.join(1000);  // Waits max 1 second

üß™ Example:
```java
public class JoinExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 started");
            try { Thread.sleep(2000); } catch (InterruptedException e) {}
            System.out.println("Thread 1 finished");
        });

        t1.start();
        t1.join();  // Main thread waits for t1 to complete
        System.out.println("Main thread resumes after t1");
    }
}
```

‚∏ª

# üîπ 2. Thread.setPriority() and Thread Priority

‚úÖ What it does:

	‚Ä¢	Sets a thread‚Äôs priority (from 1 to 10).
	‚Ä¢	Helps the Thread Scheduler decide which thread to run first (but it‚Äôs not guaranteed).

‚úÖ Priority Range:
```
Constant	           Value
Thread.MIN_PRIORITY	    1
Thread.NORM_PRIORITY	5
Thread.MAX_PRIORITY	   10
```
‚ö†Ô∏è Important:

	‚Ä¢	Priority is just a hint to the JVM ‚Äî not always respected.
	‚Ä¢	Behavior may vary across platforms and JVM implementations.

üß™ Example:

```java
public class PriorityExample {
    public static void main(String[] args) {
        Thread low = new Thread(() -> {
            for (int i = 0; i < 5; i++) System.out.println("Low Priority");
        });
        Thread high = new Thread(() -> {
            for (int i = 0; i < 5; i++) System.out.println("High Priority");
        });

        low.setPriority(Thread.MIN_PRIORITY);
        high.setPriority(Thread.MAX_PRIORITY);

        low.start();
        high.start();
    }
}
```

‚∏ª

# Fail-Fast vs Fail-Safe

1. Fail-Fast Iterator

A fail-fast iterator immediately throws an exception if the underlying collection is structurally modified while iterating.

üî• Example collections (fail-fast)

	‚Ä¢	ArrayList
	‚Ä¢	HashMap
	‚Ä¢	LinkedList
	‚Ä¢	HashSet
	‚Ä¢	Vector (iterator)
	‚Ä¢	Most collections from java.util package

üî• Behavior

If the collection is modified (add/remove) during iteration:

üëâ ConcurrentModificationException is thrown.

‚úî Why?

Fail-fast iterators use a variable called modCount.

Every structural modification changes the modCount.

Iterator compares expectedModCount with modCount. If mismatch ‚Üí throw exception.

‚∏ª

‚ùå Fail-Fast Example
```java
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {          // iterator internally
    list.add("D");               // modification during iteration
}
```
üëâ This throws ConcurrentModificationException.

‚∏ª

2. Fail-Safe Iterator

Fail-safe iterators do NOT throw exceptions if the collection is modified during iteration.

üî• Example collections (fail-safe)

Collections from java.util.concurrent package:

	‚Ä¢	CopyOnWriteArrayList
	‚Ä¢	ConcurrentHashMap
	‚Ä¢	ConcurrentSkipListMap
	‚Ä¢	ConcurrentSkipListSet

üî• Behavior

Fail-safe iterators work on a clone (copy) of the collection.

üëâ Modifying the original collection does not affect the iterator.
üëâ No ConcurrentModificationException.

‚∏ª

‚úî Fail-Safe Example
```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A");
list.add("B");
list.add("C");

for (String s : list) {
    list.add("D");   // allowed
}
```
üëâ No exception.
üëâ Iterator reads old snapshot; new values appear after iteration ends.

‚∏ª

üî• Key Differences
```
Feature								Fail-Fast										Fail-Safe
Behavior on modification			Throws ConcurrentModificationException			No exception
Works on							Actual collection								Copy (snapshot)
Memory usage						Low												High (copy created)
Speed								Faster											Slower
Example collections					ArrayList, HashMap, HashSet						CopyOnWriteArrayList, ConcurrentHashMap
Thread-safety						Not thread-safe									Thread-safe
Iterator type						Fail-fast iterator								Snapshot iterator
```

‚∏ª

üß† Why do they exist?

Fail-Fast

	‚Ä¢	Detect inconsistent modifications quickly.
	‚Ä¢	Prevents unpredictable behavior.

Fail-Safe

	‚Ä¢	Useful for concurrent environments.
	‚Ä¢	Allows iteration while modifications happen.

‚∏ª

üéØ Summary

Fail-fast iterators throw ConcurrentModificationException if the collection is structurally modified during iteration because they work on the actual collection. Fail-safe iterators do not throw exceptions because they work on a cloned snapshot of the collection. Fail-safe is used in concurrent collections, while fail-fast is used in regular collections.


‚∏ª

### Reentrant Lock

A ReentrantLock is a lock with the ability to be acquired multiple times by the same thread without causing a deadlock.

If a thread owns the lock, it can enter the same lock-protected code block again without blocking itself.

Each acquisition must be released the same number of times.

It is part of java.util.concurrent.locks.

‚∏ª

üîπ Why use ReentrantLock instead of synchronized?
```
Feature					synchronized	ReentrantLock
Lock acquisition		Implicit		Explicit (lock() / unlock())
Fairness				No control		Can be fair (FIFO)
Try lock					‚ùå			‚úÖ tryLock() avoids blocking
Interruptible				‚ùå			‚úÖ lockInterruptibly()
```

‚∏ª

üîπ Key Properties

	‚Ä¢	Reentrant: Same thread can acquire the lock multiple times
	‚Ä¢	Explicit unlock: Must call unlock() in finally block
	‚Ä¢	Fairness: Optional FIFO ordering

‚∏ª

üîπ Example
```java
import java.util.concurrent.locks.ReentrantLock;

public class Counter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        lock.lock(); // acquire lock
        try {
            count++;
            // even if we call increment again in the same thread, it won't deadlock
        } finally {
            lock.unlock(); // release lock
        }
    }

    public int getCount() {
        return count;
    }
}

Using tryLock() (non-blocking)

if(lock.tryLock()) {
    try {
        // do work
    } finally {
        lock.unlock();
    }
} else {
    // lock not acquired, do something else
}
```

‚∏ª

üîπ Key Points to Remember

	1.	Reentrant = same thread can acquire multiple times
	2.	Manual control vs synchronized
	3.	Supports advanced features: tryLock(), lockInterruptibly(), fairness
	4.	Always unlock in finally block to avoid deadlocks

‚∏ª

### Future vs Completable Future

üîπ 1. Future

	‚Ä¢	Introduced in Java 5 (java.util.concurrent.Future).
	‚Ä¢	Represents the result of an asynchronous computation.
	‚Ä¢	Can get the result using get(), which blocks the thread until the computation is done.
	‚Ä¢	Cannot easily chain multiple tasks or handle callbacks without extra boilerplate.
	‚Ä¢	Cannot be completed manually.

Example
```java
ExecutorService executor = Executors.newFixedThreadPool(1);

Future<Integer> future = executor.submit(() -> {
    Thread.sleep(1000);
    return 10;
});

System.out.println(future.get()); // blocks until result is ready
executor.shutdown();
```
Limitations of Future:

	‚Ä¢	Blocking get()
	‚Ä¢	No easy way to chain tasks (thenApply)
	‚Ä¢	Cannot complete manually (only by executor)

‚∏ª

üîπ 2. CompletableFuture

	‚Ä¢	Introduced in Java 8 (java.util.concurrent.CompletableFuture).
	‚Ä¢	Extends Future with non-blocking, async capabilities.
	‚Ä¢	Supports:
	‚Ä¢	Chaining (thenApply, thenAccept)
	‚Ä¢	Combining multiple futures (thenCombine, allOf, anyOf)
	‚Ä¢	Exception handling (exceptionally, handle)
	‚Ä¢	Can be completed manually using complete().

Example
```java
public static void main(String[] args) {
    CompletableFuture<Integer> cf = CompletableFuture.supplyAsync(() -> {
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
        return 20;
    });

    cf.thenApply(result -> result * 2)
      .thenAccept(result -> System.out.println("Result: " + result));

    System.out.println("Main thread continues working...");

    // No .get(), so main thread is not blocked
}
```
Output:
```
Main thread continues working...
Result: 40   <-- printed after 1 sec by another thread
```
‚∏ª
